local GUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/teuzzjheyt/Ash-Nex/refs/heads/main/Ash%20Main"))()

GUI:CreateMain({
    Name = "Ashlabs",
    title = "Nex Hub",
    ToggleUI = "LeftControl",
    WindowIcon = "home",
    Theme = {
        Background = Color3.fromRGB(25, 25, 35),
        Secondary = Color3.fromRGB(35, 35, 45),
        Accent = Color3.fromRGB(138, 43, 226),
        Text = Color3.fromRGB(255, 255, 255),
        TextSecondary = Color3.fromRGB(180, 180, 180),
        Border = Color3.fromRGB(50, 50, 60),
        NavBackground = Color3.fromRGB(20, 20, 30)
    },
    Blur = {
        Enable = false,
        value = 0.2
    },
    Config = {
        Enabled = false,
    }
})

-- Sistema de Keybinds Global com Salvamento
local KeybindSystem = {
    Keybinds = {},
    Connections = {},
    SaveFile = "Ashlabs_Keybinds.txt"
}

-- Função para salvar keybinds no arquivo
function KeybindSystem:SaveKeybinds()
    local saveData = {}
    for name, keybindData in pairs(self.Keybinds) do
        saveData[name] = keybindData.key
    end
    
    local jsonData = game:GetService("HttpService"):JSONEncode(saveData)
    
    local success, err = pcall(function()
        writefile(self.SaveFile, jsonData)
    end)
    
    if success then
        print("Keybinds salvos com sucesso!")
    else
        warn("Erro ao salvar keybinds:", err)
    end
end

-- Função para carregar keybinds do arquivo
function KeybindSystem:LoadKeybinds()
    local success, fileData = pcall(function()
        return readfile(self.SaveFile)
    end)
    
    if success and fileData then
        local success2, savedData = pcall(function()
            return game:GetService("HttpService"):JSONDecode(fileData)
        end)
        
        if success2 and savedData then
            return savedData
        end
    end
    return nil
end

-- Função para registrar um keybind
function KeybindSystem:RegisterKeybind(name, defaultKey, callback)
    -- Primeiro tenta carregar do arquivo salvo
    local savedKeybinds = self:LoadKeybinds()
    local actualKey = defaultKey
    
    if savedKeybinds and savedKeybinds[name] then
        actualKey = savedKeybinds[name]
        print("Keybind carregado: " .. name .. " = " .. actualKey)
    end
    
    self.Keybinds[name] = {
        key = actualKey,
        callback = callback,
        enabled = true
    }
    return self.Keybinds[name]
end

-- Função para atualizar um keybind
function KeybindSystem:UpdateKeybind(name, newKey)
    if self.Keybinds[name] then
        self.Keybinds[name].key = newKey
        -- Salva automaticamente quando atualiza
        self:SaveKeybinds()
    end
end

-- Sistema de input
local UserInputService = game:GetService("UserInputService")

-- Conexão principal para detectar keybinds
KeybindSystem.Connections.main = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.UserInputType == Enum.UserInputType.Keyboard then
        local key = input.KeyCode.Name
        
        for name, keybindData in pairs(KeybindSystem.Keybinds) do
            if keybindData.enabled and keybindData.key == key then
                keybindData.callback()
                break
            end
        end
    end
end)

-- Variáveis para os toggles que serão controlados por keybinds
local aimbotToggle, espToggle, brainrotEspToggle, timerEspToggle, desyncToggle, floatToggle, travarToggle, antiBeeToggle, antiLagToggle

local main = GUI:CreateTab("Main", "home")

GUI:CreateSection({
    parent = main, 
    text = "Main"
})

        

local visual = GUI:CreateTab("Visual", "eye")

GUI:CreateSection({
    parent = visual, 
    text = "Visual"
})


espToggle = GUI:CreateToggle({
    parent = visual,
    text = "Esp Inimigos",
    default = true,
    callback = function(state)
        _G.IsEspPlayerEnabled = state

        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local CoreGui = game:GetService("CoreGui")
        local Camera = game:GetService("Workspace").CurrentCamera
        local localPlayer = Players.LocalPlayer

        local espSettings = {
            enabled = state,
            maxDistance = 2000,
            forceMaterial = true,
            forceTransparency = 0.5,
            outlineEnabled = true,
            glowEnabled = true,
            nameTagEnabled = true,
            nameTagSize = 14,
            nameTagColor = Color3.fromRGB(0, 255, 255),
            checkInterval = 0.5,
            playerColor = Color3.fromRGB(0, 255, 255),
        }

        local espData = {}
        local playerConnections = {}
        local nameTags = {}
        local monitorThread = nil

        local function forcePartVisibility(part)
            if not part then return end
            part.LocalTransparencyModifier = 0
            part.CastShadow = true
            if espSettings.forceMaterial then
                part.Material = Enum.Material.ForceField
                part.Transparency = espSettings.forceTransparency
            end
        end

        local function updateNameTag(player, character)
            if not espSettings.nameTagEnabled or not character or not character:FindFirstChild("HumanoidRootPart") then return end
            local humanoidRootPart = character.HumanoidRootPart
            if nameTags[player] then nameTags[player]:Destroy() nameTags[player] = nil end

            local billboard = Instance.new("BillboardGui")
            billboard.Name = "FixedNameESP"
            billboard.Adornee = humanoidRootPart
            billboard.Size = UDim2.new(0, 200, 0, 50)
            billboard.StudsOffset = Vector3.new(0, 2.5, 0)
            billboard.AlwaysOnTop = true
            billboard.MaxDistance = espSettings.maxDistance
            billboard.Parent = CoreGui

            local nameLabel = Instance.new("TextLabel")
            nameLabel.Size = UDim2.new(1, 0, 1, 0)
            nameLabel.Text = player.Name
            nameLabel.TextColor3 = espSettings.nameTagColor
            nameLabel.TextSize = espSettings.nameTagSize
            nameLabel.Font = Enum.Font.SourceSansBold
            nameLabel.BackgroundTransparency = 1
            nameLabel.TextStrokeTransparency = 0.5
            nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            nameLabel.Parent = billboard

            nameTags[player] = billboard

            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.Died:Connect(function()
                    if nameTags[player] then
                        nameTags[player]:Destroy()
                        nameTags[player] = nil
                    end
                end)
            end
        end

        local function cleanPlayerEsp(player)
            if espData[player] then
                for _, conn in pairs(espData[player].connections) do
                    conn:Disconnect()
                end
                if espData[player].highlight then espData[player].highlight:Destroy() end
                espData[player] = nil
            end
            if nameTags[player] then
                nameTags[player]:Destroy()
                nameTags[player] = nil
            end
        end

        local function applyEsp(player, character)
            if not character then return end
            cleanPlayerEsp(player)

            espData[player] = {parts = {}, connections = {}}

            local function processPart(part)
                if part:IsA("BasePart") or part:IsA("MeshPart") or part:IsA("Part") then
                    forcePartVisibility(part)
                    local conn = part:GetPropertyChangedSignal("Transparency"):Connect(function()
                        forcePartVisibility(part)
                    end)
                    table.insert(espData[player].connections, conn)
                end
            end

            for _, part in pairs(character:GetDescendants()) do
                processPart(part)
            end

            local descendantAddedConn = character.DescendantAdded:Connect(function(part)
                processPart(part)
            end)
            table.insert(espData[player].connections, descendantAddedConn)

            if espSettings.glowEnabled then
                local highlight = Instance.new("Highlight")
                highlight.Name = "UniversalESPHighlight"
                highlight.Adornee = character
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.FillColor = espSettings.playerColor
                highlight.OutlineColor = espSettings.playerColor
                highlight.FillTransparency = 0.3
                highlight.Parent = CoreGui
                espData[player].highlight = highlight
            end

            if espSettings.nameTagEnabled then
                updateNameTag(player, character)
            end

            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local diedConn = humanoid.Died:Connect(function()
                    if nameTags[player] then
                        nameTags[player]:Destroy()
                        nameTags[player] = nil
                    end
                    delay(3, function()
                        if player.Character and _G.IsEspPlayerEnabled then
                            applyEsp(player, player.Character)
                        end
                    end)
                end)
                table.insert(espData[player].connections, diedConn)
            end
        end

        local function removeEsp(player)
            cleanPlayerEsp(player)
            if playerConnections[player] then
                for _, conn in pairs(playerConnections[player]) do
                    conn:Disconnect()
                end
                playerConnections[player] = nil
            end
        end

        local function monitorAllPlayers()
            while _G.IsEspPlayerEnabled do
                wait(espSettings.checkInterval)
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= localPlayer then
                        local character = player.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local distance = 0
                            if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                distance = (character.HumanoidRootPart.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
                            end
                            if distance <= espSettings.maxDistance or distance == 0 then
                                if not espData[player] or espData[player].character ~= character then
                                    applyEsp(player, character)
                                    espData[player].character = character
                                end
                            else
                                removeEsp(player)
                            end
                        else
                            removeEsp(player)
                        end
                    end
                end
            end
            for player, _ in pairs(espData) do
                removeEsp(player)
            end
        end

        local function setupAutoReconnect()
            for player, connections in pairs(playerConnections) do
                for _, conn in pairs(connections) do
                    conn:Disconnect()
                end
            end
            playerConnections = {}

            for _, player in pairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    playerConnections[player] = {}
                    local charAddedConn = player.CharacterAdded:Connect(function(character)
                        if _G.IsEspPlayerEnabled then
                            wait(2)
                            applyEsp(player, character)
                        end
                    end)
                    table.insert(playerConnections[player], charAddedConn)
                    local charRemovingConn = player.CharacterRemoving:Connect(function()
                        cleanPlayerEsp(player)
                    end)
                    table.insert(playerConnections[player], charRemovingConn)
                    if player.Character and _G.IsEspPlayerEnabled then
                        applyEsp(player, player.Character)
                    end
                end
            end

            Players.PlayerAdded:Connect(function(player)
                if player ~= localPlayer then
                    playerConnections[player] = {}
                    local charAddedConn = player.CharacterAdded:Connect(function(character)
                        if _G.IsEspPlayerEnabled then
                            wait(2)
                            applyEsp(player, character)
                        end
                    end)
                    table.insert(playerConnections[player], charAddedConn)
                    local charRemovingConn = player.CharacterRemoving:Connect(function()
                        cleanPlayerEsp(player)
                    end)
                    table.insert(playerConnections[player], charRemovingConn)
                end
            end)
        end

        if state then
            setupAutoReconnect()
            monitorThread = task.spawn(monitorAllPlayers)
            print("ESP Inimigos Ativado!")
        else
            _G.IsEspPlayerEnabled = false
            for _, player in pairs(Players:GetPlayers()) do
                removeEsp(player)
            end
            for player, connections in pairs(playerConnections) do
                for _, conn in pairs(connections) do
                    conn:Disconnect()
                end
            end
            playerConnections = {}
            monitorThread = nil
            print("ESP Inimigos Desativado!")
        end
    end
})

-- ESP Brainrot Corrigido
brainrotEspToggle = GUI:CreateToggle({
    parent = visual,
    text = "Esp Melhor Brainrot",
    default = true,
    callback = function(state)
        _G.IsBrainrotEspEnabled = state

        local workspace = game:GetService("Workspace")
        local Players = game:GetService("Players")
        local localPlayer = Players.LocalPlayer

        -- Funções auxiliares do código original
        local function getMyPlot()
            local plots = workspace:FindFirstChild("Plots")
            if not plots then return nil end
            for _, plot in ipairs(plots:GetChildren()) do
                local plotSign = plot:FindFirstChild("PlotSign")
                if plotSign then
                    local yourBase = plotSign:FindFirstChild("YourBase")
                    if yourBase and yourBase.Enabled then
                        return plot
                    end
                end
            end
            return nil
        end

        local function parseValue(str)
            if not str then return 0 end
            local cleanStr = string.gsub(str, "/s", "")
            local num, suffix = string.match(cleanStr, "[$]?[%s]*([%d%.]+)[%s]*([MKBT]?)")
            if not num then return 0 end
            num = tonumber(num)
            if not num then return 0 end
            if suffix == "K" then num = num * 1e3
            elseif suffix == "M" then num = num * 1e6
            elseif suffix == "B" then num = num * 1e9
            elseif suffix == "T" then num = num * 1e12 end
            return num
        end

        local function isRaceTrackObject(obj)
            local parent = obj.Parent
            while parent do
                local nameLower = parent.Name:lower()
                if string.find(nameLower, "race") or string.find(nameLower, "track") or string.find(nameLower, "obstacle") then
                    return true
                end
                parent = parent.Parent
            end
            local nameLower = obj.Name:lower()
            return string.find(nameLower, "brainrot") or string.find(nameLower, "obstacle") or string.find(nameLower, "race") or string.find(nameLower, "track")
        end

        local function findAnimalInfo(animalModel)
            local textLabels = {}
            for _, gui in ipairs(animalModel:GetDescendants()) do
                if gui:IsA("TextLabel") then
                    table.insert(textLabels, gui)
                elseif gui:IsA("BillboardGui") then
                    for _, child in ipairs(gui:GetChildren()) do
                        if child:IsA("TextLabel") then
                            table.insert(textLabels, child)
                        end
                    end
                end
            end

            local displayName, valuePerSecond

            for _, label in ipairs(textLabels) do
                if string.find(label.Text, "[%d%.]+[MB]/s") or string.find(label.Text, "[$][%d%.]+[MB]/s") then
                    valuePerSecond = label
                    break
                end
            end
            if not valuePerSecond then
                for _, label in ipairs(textLabels) do
                    if string.find(label.Text, "/s") then
                        valuePerSecond = label
                        break
                    end
                end
            end

            local nomesEspecificosAceitos = {
                "SABARÁ", "Tracoolucotulu Delapehaburista", "Nucleare Dinosasuro", 
                "Gacinói", "Muniz", "Coleto", "Colafar", "Colaf", "Ummand",
                "La Extina", "Exthra Balerina", "Rinne Red", "Ascara", "Mykhlo",
                "La Extinta Grande", "Tracoducotulu Dela", "Tralaledon",
                "Dragon Cannelloni", "Tictac Sahur"
            }

            local textosParaIgnorar = {
                "Lava", "Galaxy", "Bloodron", "Tictac", "Sahur", "Candy", "Gold",
                "Secret", "Diamond", "Rainbow", "BloodRot", "Bloodrot", "Brainrot", 
                "God", "Legendary", "Mythical", "Exclusive", "Normal",
                "Watermelon", "P1", "Brr", "es", "Teh", "Patipum", "Spook"
            }

            for _, label in ipairs(textLabels) do
                local text = label.Text
                if not text then continue end

                local ehNomeEspecifico = false
                for _, nomeEspecial in ipairs(nomesEspecificosAceitos) do
                    if string.lower(text) == string.lower(nomeEspecial) then
                        displayName = label
                        ehNomeEspecifico = true
                        break
                    end
                end
                if ehNomeEspecifico then break end

                local deveIgnorar = false
                for _, textoIgnorar in ipairs(textosParaIgnorar) do
                    if string.lower(text) == string.lower(textoIgnorar) then
                        deveIgnorar = true
                        break
                    end
                end

                if not deveIgnorar and not string.find(text, "/s") and not string.find(text, "[$MKBT]") and not string.match(text, "^%d") and #text > 3 and #text < 25 then
                    displayName = label
                    break
                end
            end

            if not displayName then
                for _, label in ipairs(textLabels) do
                    local text = label.Text
                    if string.find(text, "/s") and not string.find(text, "[$]") and not string.find(text, "[MB]/s") then
                        displayName = label
                        break
                    end
                end
            end

            return displayName, valuePerSecond
        end

        local function getAnimalSpawnLocations()
            local locations = {}
            local myPlot = getMyPlot()
            
            for _, plot in ipairs(workspace.Plots:GetChildren()) do
                if plot ~= myPlot then 
                    table.insert(locations, plot) 
                end
            end

            local possibleWildAreas = {
                workspace:FindFirstChild("WildAnimals"),
                workspace:FindFirstChild("Animals"),
                workspace:FindFirstChild("SpawnedAnimals"),
                workspace:FindFirstChild("Pets"),
                workspace:FindFirstChild("PetsFolder")
            }

            for _, area in ipairs(possibleWildAreas) do
                if area then table.insert(locations, area) end
            end

            for _, child in ipairs(workspace:GetChildren()) do
                if child:IsA("Folder") or child:IsA("Model") then
                    local nameLower = child.Name:lower()
                    if string.find(nameLower, "animal") or string.find(nameLower, "pet") or string.find(nameLower, "wild") or string.find(nameLower, "spawn") then
                        table.insert(locations, child)
                    end
                end
            end

            return locations
        end

        local function findBestBrainrot_Metodo1()
            local best = { animalModel = nil, name = "", valueStr = "", valueNum = 0 }
            local spawnLocations = getAnimalSpawnLocations()
            local myPlot = getMyPlot()

            for _, location in ipairs(spawnLocations) do
                if location and location:IsDescendantOf(workspace) then
                    for _, obj in ipairs(location:GetDescendants()) do
                        if obj:IsA("Model") and not obj:FindFirstChild("Base") and not isRaceTrackObject(obj) then
                            local isInMyPlot = false
                            if myPlot then
                                local parent = obj.Parent
                                while parent do
                                    if parent == myPlot then
                                        isInMyPlot = true
                                        break
                                    end
                                    parent = parent.Parent
                                end
                            end
                            if not isInMyPlot then
                                local displayName, generation = findAnimalInfo(obj)
                                if displayName and generation then
                                    local valueNum = parseValue(generation.Text)
                                    local nameText = displayName.Text
                                    local isPerSecond = string.find(generation.Text, "/s")
                                    local textosInvalidos = {"Lava", "Galaxy", "Bloodron", "Tictac", "Sahur", "Candy"}
                                    local ehValido = true
                                    for _, textoInvalido in ipairs(textosInvalidos) do
                                        if string.lower(nameText) == string.lower(textoInvalido) then
                                            ehValido = false
                                            break
                                        end
                                    end
                                    if isPerSecond and ehValido and valueNum > best.valueNum then
                                        best.valueNum = valueNum
                                        best.valueStr = generation.Text
                                        best.name = displayName.Text
                                        best.animalModel = obj
                                    end
                                end
                            end
                        end
                    end
                end
            end

            return best
        end

        local function findBestBrainrot_Metodo2()
            local best = { podium = nil, animalModel = nil, name = "", valueStr = "", valueNum = 0 }
            local myPlot = getMyPlot()
            
            for _, plot in ipairs(workspace.Plots:GetChildren()) do
                if plot ~= myPlot then
                    local animalPodiums = plot:FindFirstChild("AnimalPodiums")
                    if animalPodiums then
                        for _, podium in ipairs(animalPodiums:GetChildren()) do
                            local attach = podium:FindFirstChild("Base") and podium.Base:FindFirstChild("Spawn") and podium.Base.Spawn:FindFirstChild("Attachment")
                            if attach and attach:FindFirstChild("AnimalOverhead") then
                                local overhead = attach.AnimalOverhead
                                local displayName = overhead:FindFirstChild("DisplayName")
                                local generation = overhead:FindFirstChild("Generation")
                                local hasAnimal = false
                                for _, obj in ipairs(podium:GetChildren()) do
                                    if (obj:IsA("Model") or obj:IsA("MeshPart") or obj:IsA("Part")) and obj.Name ~= "Base" then
                                        hasAnimal = true
                                        break
                                    end
                                end
                                if displayName and generation and displayName:IsA("TextLabel") and generation:IsA("TextLabel") and hasAnimal then
                                    local valueNum = parseValue(generation.Text)
                                    if valueNum > best.valueNum then
                                        best.valueNum = valueNum
                                        best.valueStr = generation.Text
                                        best.name = displayName.Text
                                        best.podium = podium
                                        for _, obj in ipairs(podium:GetChildren()) do
                                            if (obj:IsA("Model") or obj:IsA("MeshPart") or obj:IsA("Part")) and obj.Name ~= "Base" then
                                                best.animalModel = obj
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            return best
        end

        local function findBestBrainrotCombined()
            local best1 = findBestBrainrot_Metodo1()
            local best2 = findBestBrainrot_Metodo2()
            if best1.valueNum > best2.valueNum then
                return best1
            else
                return best2
            end
        end

        -- ESP Functions
        local function clearESP()
            if _G.LastBrainrotESP and _G.LastBrainrotESP.Parent then
                _G.LastBrainrotESP:Destroy()
                _G.LastBrainrotESP = nil
            end
            if _G.LastBrainrotHighlight and _G.LastBrainrotHighlight.Parent then
                _G.LastBrainrotHighlight:Destroy()
                _G.LastBrainrotHighlight = nil
            end
        end

        local function highlightAnimal(animalModel, isPodium)
            if _G.LastBrainrotHighlight and _G.LastBrainrotHighlight.Parent then
                _G.LastBrainrotHighlight:Destroy()
            end
            if animalModel then
                local highlight = Instance.new("Highlight")
                highlight.Name = "AnimalHighlight"
                if isPodium then
                    highlight.FillColor = Color3.fromRGB(135, 206, 250)
                    highlight.FillTransparency = 0.7
                    highlight.OutlineColor = Color3.fromRGB(0, 191, 255)
                else
                    highlight.FillColor = Color3.fromRGB(255, 165, 0)
                    highlight.FillTransparency = 0.7
                    highlight.OutlineColor = Color3.fromRGB(255, 69, 0)
                end
                highlight.OutlineTransparency = 0
                highlight.Adornee = animalModel
                highlight.Parent = animalModel
                _G.LastBrainrotHighlight = highlight
            end
        end

        local function createESP(animalModel, name, value)
            local rootPart = animalModel:FindFirstChild("HumanoidRootPart") or animalModel:FindFirstChild("Head") or animalModel:FindFirstChild("Torso") or animalModel:FindFirstChildWhichIsA("Part")
            local adornee = rootPart or animalModel

            local attachment = Instance.new("Attachment")
            attachment.Name = "ESPAttachment"
            attachment.Parent = adornee

            local esp = Instance.new("BillboardGui")
            esp.Name = "BrainrotESP"
            esp.Size = UDim2.new(0, 400, 0, 120)
            esp.Adornee = attachment
            esp.AlwaysOnTop = true
            esp.MaxDistance = 1000
            esp.ExtentsOffset = Vector3.new(0, 5, 0)
            esp.Parent = attachment

            local container = Instance.new("Frame")
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1
            container.Parent = esp

            local nameLabel = Instance.new("TextLabel")
            nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
            nameLabel.Position = UDim2.new(0, 0, 0, 0)
            nameLabel.BackgroundTransparency = 1
            nameLabel.BorderSizePixel = 0
            nameLabel.TextStrokeTransparency = 0.3
            nameLabel.TextSize = 32
            nameLabel.Font = Enum.Font.GothamBold
            nameLabel.Text = name
            nameLabel.TextColor3 = Color3.new(1, 1, 0)
            nameLabel.TextWrapped = true
            nameLabel.Parent = container

            local valueLabel = Instance.new("TextLabel")
            valueLabel.Size = UDim2.new(1, 0, 0.5, 0)
            valueLabel.Position = UDim2.new(0, 0, 0.5, 0)
            valueLabel.BackgroundTransparency = 1
            valueLabel.BorderSizePixel = 0
            valueLabel.TextStrokeTransparency = 0.3
            valueLabel.TextSize = 28
            valueLabel.Font = Enum.Font.GothamBold
            valueLabel.Text = value
            valueLabel.TextColor3 = Color3.new(0, 1, 0)
            valueLabel.TextWrapped = true
            valueLabel.Parent = container

            return esp, attachment
        end

        local function showBestBrainrotESP()
            clearESP()
            local best = findBestBrainrotCombined()
            if best.name == "" or not best.animalModel then return end
            local isPodium = (best.podium ~= nil)
            highlightAnimal(best.animalModel, isPodium)
            _G.LastBrainrotESP, _G.LastBrainrotAttachment = createESP(best.animalModel, best.name, best.valueStr)
        end

        -- Liga ou desliga ESP
        if state then
            _G.BrainrotEspLoop = task.spawn(function()
                while _G.IsBrainrotEspEnabled do
                    pcall(showBestBrainrotESP)
                    task.wait(3)
                end
            end)
        else
            if _G.BrainrotEspLoop then
                task.cancel(_G.BrainrotEspLoop)
                _G.BrainrotEspLoop = nil
            end
            clearESP()
        end
    end
})

-- ESP Timer Base Corrigido
timerEspToggle = GUI:CreateToggle({
    parent = visual, 
    text = "Esp Timer Base", 
    default = true, 
    callback = function(state)
        _G.IsEspTimerBaseEnabled = state

        -- Ativar ESP
        if state then
            -- Serviços
            local Players = game:GetService("Players")

            -- Função para criar o Billboard na base
            local function CreateESP(basePlot)
                if basePlot:FindFirstChild("BaseTimerESP") then
                    return basePlot:FindFirstChild("BaseTimerESP"):FindFirstChild("TextLabel"), basePlot:FindFirstChild("BaseTimerESP")
                end

                local billboard = Instance.new("BillboardGui")
                billboard.Size = UDim2.new(0, 200, 0, 50)
                billboard.AlwaysOnTop = true
                billboard.StudsOffset = Vector3.new(0, 5, 0)
                billboard.Name = "BaseTimerESP"

                local label = Instance.new("TextLabel", billboard)
                label.Size = UDim2.new(1, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.TextColor3 = Color3.fromRGB(255, 255, 255)
                label.TextStrokeTransparency = 0.2
                label.Font = Enum.Font.SourceSansBold
                label.TextScaled = true
                label.Text = "Carregando..."

                local part = basePlot:FindFirstChildWhichIsA("BasePart")
                if part then
                    billboard.Parent = part
                end

                return label, billboard
            end

            -- Função para achar RemainingTime da base
            local function FindRemainingTime(plot)
                for _, desc in pairs(plot:GetDescendants()) do
                    if desc:IsA("TextLabel") and desc.Name == "RemainingTime" then
                        return desc
                    end
                end
            end

            -- Cria ESP para todas as bases
            _G.BaseEspElements = {}
            for _, plot in pairs(workspace.Plots:GetChildren()) do
                local lbl, billboard = CreateESP(plot)
                _G.BaseEspElements[plot] = {Label = lbl, Billboard = billboard}
            end

            -- Loop de atualização
            _G.BaseEspLoop = task.spawn(function()
                while _G.IsEspTimerBaseEnabled do
                    task.wait(1)
                    for plot, uiElements in pairs(_G.BaseEspElements) do
                        if not plot or not plot.Parent or not uiElements.Label or not uiElements.Label.Parent then continue end
                        
                        local uiLabel = uiElements.Label
                        local timer = FindRemainingTime(plot)

                        if timer and timer.Text ~= "" then
                            local num = tonumber(timer.Text:match("%d+"))
                            if num and num > 0 then
                                uiLabel.Text = timer.Text
                                if num <= 10 then
                                    uiLabel.TextColor3 = Color3.fromRGB(255, 0, 0) -- vermelho
                                else
                                    uiLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- branco
                                end
                            else
                                uiLabel.Text = "Aberta"
                                uiLabel.TextColor3 = Color3.fromRGB(0, 255, 0) -- verde
                            end
                        else
                            uiLabel.Text = "Aberta"
                            uiLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
                        end
                    end
                end
            end)

        -- Desativar ESP
        else
            if _G.BaseEspElements then
                for _, uiElements in pairs(_G.BaseEspElements) do
                    if uiElements.Billboard and uiElements.Billboard.Parent then
                        uiElements.Billboard:Destroy()
                    end
                end
                _G.BaseEspElements = nil
            end
            if _G.BaseEspLoop then
                task.cancel(_G.BaseEspLoop)
                _G.BaseEspLoop = nil
            end
        end
    end
})

local outros = GUI:CreateTab("Outros", "shield")

GUI:CreateSection({
    parent = outros, 
    text = "Outros"
})

desyncToggle = GUI:CreateToggle({
    parent = outros, 
    text = "Desync",
    default = true, 
    callback = function(state)
        if state then
            local url = "https://raw.githubusercontent.com/teuzzjheyt/Desync/refs/heads/main/Desync"
            local success, err = pcall(function()
                loadstring(game:HttpGet(url, true))()
            end)
            if not success then
                warn("Erro ao injetar a script Desync:", err)
            end
        end
    end
})

floatToggle = GUI:CreateToggle({
    parent = outros, 
    text = "Float Base",
    default = true, 
    callback = function(state)
        if state then
            local url = "https://raw.githubusercontent.com/teuzzjheyt/Float-Base/refs/heads/main/Floatbase"
            local success, err = pcall(function()
                loadstring(game:HttpGet(url, true))()
            end)
            if not success then
                warn("Erro ao injetar a script Desync:", err)
            end
        end
    end
})

-- Variáveis globais para o Infinite Jump
local infiniteJumpEnabled = false
local renderSteppedConnection = nil
local characterAddedConnection = nil

infiniteJumpToggle = GUI:CreateToggle({
    parent = outros, 
    text = "Infinite Jump",
    default = false, 
    callback = function(state)
        local LocalPlayer = game:GetService("Players").LocalPlayer
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")
        
        if state then
            -- Ativar Infinite Jump
            infiniteJumpEnabled = true
            
            local function enableInfiniteJump()
                if renderSteppedConnection then
                    renderSteppedConnection:Disconnect()
                    renderSteppedConnection = nil
                end

                renderSteppedConnection = RunService.RenderStepped:Connect(function()
                    local character = LocalPlayer.Character
                    if not character then return end
                    
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    
                    if humanoidRootPart and humanoid and infiniteJumpEnabled then
                        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                            humanoidRootPart.Velocity = Vector3.new(
                                humanoidRootPart.Velocity.X,
                                40, -- Força do pulo
                                humanoidRootPart.Velocity.Z
                            )
                        end
                    end
                end)
            end

            -- Configurar reconexão quando o personagem morrer/renascer
            if characterAddedConnection then
                characterAddedConnection:Disconnect()
            end
            
            characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(character)
                if infiniteJumpEnabled then
                    wait(1)
                    enableInfiniteJump()
                end
            end)

            -- Ativar inicialmente
            enableInfiniteJump()

        else
            -- Desativar Infinite Jump
            infiniteJumpEnabled = false
            
            if renderSteppedConnection then
                renderSteppedConnection:Disconnect()
                renderSteppedConnection = nil
            end
            
            if characterAddedConnection then
                characterAddedConnection:Disconnect()
                characterAddedConnection = nil
            end
        end
    end
})
travarToggle = GUI:CreateToggle({
    parent = outros, 
    text = "Travar Players", 
    default = true,
    callback = function(state)
        if state then
            local url = "https://raw.githubusercontent.com/teuzzjheyt/Nxreducefps/refs/heads/main/Nxreducefps.lua"
            local success, err = pcall(function()
                loadstring(game:HttpGet(url, true))()
            end)
            if not success then
                warn("Erro ao injetar a script:", err)
            end
        end
    end
})

GUI:CreateToggle({
    parent = outros, 
    text = "Steal Flor", 
    default = true,
    callback = function(state)
        if state then
            local url = "https://raw.githubusercontent.com/teuzzjheyt/3rd-flor/refs/heads/main/3rdflor"
            
            local success, err = pcall(function()
                loadstring(game:HttpGet(url, true))()
            end)
            
            if not success then
                warn("Erro ao injetar a script 3D Floor:", err)
            end
        end
    end
})

-- Variáveis globais para manter o estado
local spammerVariables = {
    visiblePrompts = {},
    isSpammerActive = false,
    spammerLoop = nil,
    connections = {}
}

-- Toggle para o Proximity Prompt Spammer
GUI:CreateToggle({
    parent = outros,
    text = "Auto Pull",
    callback = function(state)
        local Players = game:GetService('Players')
        
        local function addVisiblePrompt(prompt)
            if prompt and prompt:IsA('ProximityPrompt') then
                if not table.find(spammerVariables.visiblePrompts, prompt) then
                    table.insert(spammerVariables.visiblePrompts, prompt)
                end
            end
        end

        local function removeVisiblePrompt(prompt)
            for i, p in ipairs(spammerVariables.visiblePrompts) do
                if p == prompt then
                    table.remove(spammerVariables.visiblePrompts, i)
                    break
                end
            end
        end

        local function setupPromptEvents()
            -- Limpar conexões anteriores
            for _, connection in ipairs(spammerVariables.connections) do
                connection:Disconnect()
            end
            table.clear(spammerVariables.connections)
            
            -- Configurar eventos para prompts existentes
            for _, prompt in pairs(game:GetDescendants()) do
                if prompt:IsA('ProximityPrompt') then
                    local conn1 = prompt.PromptShown:Connect(function()
                        addVisiblePrompt(prompt)
                    end)
                    local conn2 = prompt.PromptHidden:Connect(function()
                        removeVisiblePrompt(prompt)
                    end)
                    table.insert(spammerVariables.connections, conn1)
                    table.insert(spammerVariables.connections, conn2)
                end
            end

            -- Configurar evento para novos prompts
            local descendantAddedConn = game.DescendantAdded:Connect(function(descendant)
                if descendant:IsA('ProximityPrompt') then
                    local conn1 = descendant.PromptShown:Connect(function()
                        addVisiblePrompt(descendant)
                    end)
                    local conn2 = descendant.PromptHidden:Connect(function()
                        removeVisiblePrompt(descendant)
                    end)
                    table.insert(spammerVariables.connections, conn1)
                    table.insert(spammerVariables.connections, conn2)
                end
            end)
            table.insert(spammerVariables.connections, descendantAddedConn)
        end

        local function triggerWithHold(prompt, holdTime)
            holdTime = holdTime or 0.5
            fireproximityprompt(prompt)
            prompt:InputHoldBegin()
            wait(holdTime)
            prompt:InputHoldEnd()
        end

        local function startSpammer(interval)
            interval = interval or 1
            spammerVariables.spammerLoop = task.spawn(function()
                while spammerVariables.isSpammerActive do
                    for _, prompt in ipairs(spammerVariables.visiblePrompts) do
                        if prompt and prompt.Parent and spammerVariables.isSpammerActive then
                            triggerWithHold(prompt, 0.5)
                        end
                    end
                    task.wait(interval)
                end
            end)
        end

        local function stopSpammer()
            spammerVariables.isSpammerActive = false
            if spammerVariables.spammerLoop then
                task.cancel(spammerVariables.spammerLoop)
                spammerVariables.spammerLoop = nil
            end
            
            -- Limpar todas as conexões
            for _, connection in ipairs(spammerVariables.connections) do
                connection:Disconnect()
            end
            table.clear(spammerVariables.connections)
            
            -- Limpar a lista de prompts visíveis
            table.clear(spammerVariables.visiblePrompts)
        end

        -- Executar baseado no estado do toggle
        if state then
            -- Ligar o spammer
            spammerVariables.isSpammerActive = true
            setupPromptEvents()
            startSpammer(1)
           
        else
            -- Desligar o spammer
            stopSpammer()
            
        end
    end
})

local servidor = GUI:CreateTab("Servidor", "cloud")

GUI:CreateSection({
    parent = servidor, 
    text = "Server Functions"
})

local TeleportService = game:GetService("TeleportService")

-- Variável para armazenar o Job ID
local currentJobId = ""

-- Input para colar o Job ID
GUI:CreateInput({
    parent = servidor, 
    text = "Job Id", 
    placeholder = "Cole o Job ID aqui e pressione ENTER", 
    flag = "TeleportInput",
    callback = function(text)
        print("Input text:", text)
        currentJobId = text -- Salva o Job ID para usar no botão
        
        -- Sistema de teleporte via ENTER
        local jobId = string.gsub(text, "%s+", "") -- Remove espaços
        
        if jobId == "" then
            GUI:CreateNotify({title = "Erro", description = "Digite um Job ID"})
            return
        end
        
        -- Valida se é um UUID ou número
        local isValid = false
        
        -- Verifica se é UUID (formato com hífens)
        if string.match(jobId, "^[a-fA-F0-9%-]+$") and #jobId >= 32 then
            isValid = true
        -- Verifica se é número (Job ID antigo)
        elseif tonumber(jobId) then
            isValid = true
        end
        
        if isValid then
            GUI:CreateNotify({title = "Teleportando", description = "Job ID: " .. jobId})
            
            -- Tenta o teleporte
            local success, result = pcall(function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, game.Players.LocalPlayer)
            end)
            
            if not success then
                GUI:CreateNotify({title = "Erro", description = "Falha no teleporte: " .. tostring(result)})
            end
        else
            GUI:CreateNotify({title = "Erro", description = "Job ID inválido"})
        end
    end
})

-- Botão de Teleporte
GUI:CreateButton({
    parent = servidor, 
    text = "Teleportar via Job ID", 
    flag = "TeleportBtn",
    callback = function()
        if currentJobId == "" then
            GUI:CreateNotify({title = "Erro", description = "Cole um Job ID no campo acima primeiro!"})
            return
        end
        
        local jobId = string.gsub(currentJobId, "%s+", "") -- Remove espaços
        
        -- Validação
        local isValid = false
        if string.match(jobId, "^[a-fA-F0-9%-]+$") and #jobId >= 32 then
            isValid = true
        elseif tonumber(jobId) then
            isValid = true
        end
        
        if isValid then
            GUI:CreateNotify({title = "Teleportando", description = "Usando Job ID: " .. jobId})
            
            -- Teleporte via botão
            local success, result = pcall(function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, game.Players.LocalPlayer)
            end)
            
            if not success then
                GUI:CreateNotify({title = "Erro", description = "Falha no teleporte: " .. tostring(result)})
            end
        else
            GUI:CreateNotify({title = "Erro", description = "Job ID inválido no campo"})
        end
    end
})

GUI:CreateSection({
    parent = servidor, 
    text = "Servidor"
})

GUI:CreateToggle({
    parent = servidor, 
    text = "Auto Kick", 
    callback = function()
       
    end
})





GUI:CreateToggle({
    parent = servidor, 
    text = "Anti AFK", 
    callback = function()
       
    end
})

antiBeeToggle = GUI:CreateToggle({
    parent = servidor, 
    text = "Anti Bee",
    default = true, 
    callback = function()
        -- Script para remover efeito amarelo e zoom do BeeLauncher
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local Lighting = game:GetService("Lighting")
        local player = Players.LocalPlayer
        local camera = workspace.CurrentCamera

        -- Variáveis
        local effectsRemoved = false
        local originalFOV = camera.FieldOfView
        local connections = {}

        -- Função para remover todos os efeitos visuais
        local function removeAllEffects()
            if effectsRemoved then return end
            effectsRemoved = true

            -- Salvar FOV original
            originalFOV = camera.FieldOfView

            -- 1. Remover efeitos de COR (amarelo)
            for _, effect in pairs(Lighting:GetChildren()) do
                if effect:IsA("ColorCorrectionEffect") or 
                   effect:IsA("BloomEffect") or 
                   effect:IsA("BlurEffect") then
                    effect.Enabled = false
                end
            end

            -- 2. Conexão para manter FOV e desativar efeitos continuamente
            local mainConnection
            mainConnection = RunService.Heartbeat:Connect(function()
                if not effectsRemoved then 
                    mainConnection:Disconnect()
                    return 
                end
                
                -- Manter FOV normal (contra zoom)
                camera.FieldOfView = originalFOV

                -- Remover desfoque e amarelo continuamente
                for _, effect in pairs(Lighting:GetChildren()) do
                    if effect:IsA("BlurEffect") or effect:IsA("ColorCorrectionEffect") then
                        effect.Enabled = false
                        if effect:IsA("BlurEffect") then
                            effect.Size = 0
                        end
                    end
                end
            end)

            table.insert(connections, mainConnection)

            -- 3. Monitorar novos efeitos adicionados
            local lightingConnection = Lighting.ChildAdded:Connect(function(child)
                if effectsRemoved then
                    if child:IsA("BlurEffect") or 
                       child:IsA("ColorCorrectionEffect") or 
                       child:IsA("BloomEffect") then
                        child.Enabled = false
                        if child:IsA("BlurEffect") then
                            child.Size = 0
                        end
                    end
                end
            end)

            table.insert(connections, lightingConnection)

            -- 4. Remover ScreenGuis de efeito
            for _, gui in pairs(player.PlayerGui:GetChildren()) do
                if gui:IsA("ScreenGui") then
                    local name = string.lower(gui.Name)
                    if name:find("effect") or name:find("overlay") or name:find("filter") or name:find("blur") then
                        gui.Enabled = false
                    end
                end
            end

            -- 5. Monitorar novos ScreenGuis
            local guiConnection = player.PlayerGui.ChildAdded:Connect(function(child)
                if effectsRemoved and child:IsA("ScreenGui") then
                    local name = string.lower(child.Name)
                    if name:find("effect") or name:find("overlay") or name:find("filter") or name:find("blur") then
                        child.Enabled = false
                    end
                end
            end)

            table.insert(connections, guiConnection)
        end

        -- Executar a função diretamente ao ativar o toggle
        removeAllEffects()
    end
})

-- Anti Lag Atualizado
antiLagToggle = GUI:CreateToggle({
    parent = servidor, 
    text = "Anti Lag", 
    default = true,
    callback = function(value)
        -- Variável de estado
        local isEnabled = value

        -- Função para remover skins de um personagem
        local function removeSkinsFromCharacter(character)
            pcall(function()
                -- Remover roupas e acessórios
                for _, item in ipairs(character:GetChildren()) do
                    if item:IsA("Accessory") or item:IsA("Shirt") or item:IsA("Pants") or item:IsA("ShirtGraphic") then
                        item:Destroy()
                    end
                end
                
                -- Remover texturas do corpo
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    -- Remover bodies
                    for _, bodyPart in ipairs(character:GetChildren()) do
                        if bodyPart:IsA("BasePart") then
                            -- Remover texturas e materiais
                            bodyPart.Material = Enum.Material.SmoothPlastic
                            bodyPart.BrickColor = BrickColor.new("Medium stone grey")
                            
                            -- Remover decal (skin)
                            for _, decal in ipairs(bodyPart:GetChildren()) do
                                if decal:IsA("Decal") then
                                    decal:Destroy()
                                end
                            end
                        end
                    end
                    
                    -- Remover head mesh (cabelo, etc)
                    local head = character:FindFirstChild("Head")
                    if head then
                        for _, item in ipairs(head:GetChildren()) do
                            if item:IsA("SpecialMesh") or item:IsA("MeshPart") then
                                item:Destroy()
                            end
                        end
                    end
                end
            end)
        end

        -- Loop principal de remoção de skins
        local function startSkinRemoval()
            if _G.skinRemovalLoop then 
                _G.skinRemovalLoop:Disconnect()
            end
            
            
            -- Remover skin do próprio player primeiro
            if game.Players.LocalPlayer.Character then
                removeSkinsFromCharacter(game.Players.LocalPlayer.Character)
            end
            
            -- Remover skins de todos os outros players
            for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                if otherPlayer.Character then
                    removeSkinsFromCharacter(otherPlayer.Character)
                end
            end
            
            -- Monitorar continuamente
            _G.skinRemovalLoop = game:GetService("RunService").Heartbeat:Connect(function()
                -- Verificar todos os players no workspace
                for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                    if otherPlayer.Character and otherPlayer.Character:FindFirstChild("Humanoid") then
                        removeSkinsFromCharacter(otherPlayer.Character)
                    end
                end
                
                -- Verificar modelos que podem ser clones
                for _, model in ipairs(workspace:GetChildren()) do
                    if model:IsA("Model") and model:FindFirstChild("Humanoid") then
                        -- Verificar se é um clone (tem humanoid mas não é de um player)
                        local isPlayerCharacter = false
                        for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                            if otherPlayer.Character == model then
                                isPlayerCharacter = true
                                break
                            end
                        end
                        
                        if not isPlayerCharacter then
                            removeSkinsFromCharacter(model)
                        end
                    end
                end
            end)
        end

        -- Função para parar a remoção de skins
        local function stopSkinRemoval()
            if _G.skinRemovalLoop then
                _G.skinRemovalLoop:Disconnect()
                _G.skinRemovalLoop = nil
            end
            
            if _G.playerAddedConnection then
                _G.playerAddedConnection:Disconnect()
                _G.playerAddedConnection = nil
            end
            
            if _G.characterAddedConnection then
                _G.characterAddedConnection:Disconnect()
                _G.characterAddedConnection = nil
            end
        end

        -- Ativar Anti Lag
        if value then
            -- Monitorar quando novos players entram
            _G.playerAddedConnection = game.Players.PlayerAdded:Connect(function(otherPlayer)
                _G.characterAddedConnection = otherPlayer.CharacterAdded:Connect(function(character)
                    task.wait(1)
                    removeSkinsFromCharacter(character)
                end)
            end)

            -- Aplicar remoção de skins em players existentes
            for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                if otherPlayer.Character then
                    removeSkinsFromCharacter(otherPlayer.Character)
                end
            end

            -- Reconectar quando o personagem do player morrer
            _G.localPlayerConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
                task.wait(2)
                removeSkinsFromCharacter(character)
            end)

            -- Iniciar automaticamente
            startSkinRemoval()



        -- Desativar Anti Lag
        else
            stopSkinRemoval()
        end
    end
})

local information = GUI:CreateTab("VIPs", "crown")

GUI:CreateSection({
    parent = information, 
    text = "VIPs Functions"
})

GUI:CreateToggle({
    parent = information, 
    text = "Server Privado", 
    callback = function(value)
        if value then
            -- [Código Server Privado permanece igual...]
        end
    end
})

GUI:CreateToggle({
    parent = information, 
    text = "Notfy Vip", 
    callback = function()
       
    end
})

-- NOVA ABA DE KEYBINDS COM SISTEMA DE SALVAMENTO
local keybindsTab = GUI:CreateTab("Keybinds", "keyboard")

GUI:CreateSection({
    parent = keybindsTab, 
    text = "Keybinds - Toggle de Funções"
})

-- Função para criar UI de keybind
local keybindElements = {}

local function createKeybindUI(parent, name, defaultKey, callback)
    local keybindData = KeybindSystem:RegisterKeybind(name, defaultKey, callback)
    
    local container = Instance.new("Frame")
    container.BackgroundTransparency = 1
    container.Size = UDim2.new(1, 0, 0, 40)
    container.Parent = parent
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.6, 0, 1, 0)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = name
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Font = Enum.Font.Gotham
    label.Parent = container
    
    local keybindButton = Instance.new("TextButton")
    keybindButton.Size = UDim2.new(0.3, 0, 0.7, 0)
    keybindButton.Position = UDim2.new(0.65, 0, 0.15, 0)
    keybindButton.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
    keybindButton.BorderSizePixel = 0
    keybindButton.Text = keybindData.key -- Usa a key carregada/salva
    keybindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    keybindButton.TextSize = 12
    keybindButton.Font = Enum.Font.Gotham
    keybindButton.Parent = container
    
    local listening = false
    
    keybindButton.MouseButton1Click:Connect(function()
        if not listening then
            listening = true
            keybindButton.Text = "..."
            keybindButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
            
            local connection
            connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    local newKey = input.KeyCode.Name
                    
                    -- Atualiza o keybind no sistema
                    KeybindSystem:UpdateKeybind(name, newKey)
                    
                    -- Atualiza o botão visualmente
                    keybindButton.Text = newKey
                    keybindButton.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
                    listening = false
                    connection:Disconnect()
                    
                    print("Keybind " .. name .. " atualizado para: " .. newKey)
                    print("Keybind salvo automaticamente!")
                end
            end)
        end
    end)
    
    keybindElements[name] = {
        container = container,
        button = keybindButton,
        data = keybindData
    }
    
    return container
end

-- KEYBINDS APENAS PARA FUNÇÕES QUE JÁ EXISTEM NOS TOGGLES

-- Visual
createKeybindUI(keybindsTab, "ESP Inimigos", "F1", function()
    if espToggle then
        espToggle:Set(not espToggle:Get())
        print("ESP Inimigos toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "ESP Brainrot", "F2", function()
    if brainrotEspToggle then
        brainrotEspToggle:Set(not brainrotEspToggle:Get())
        print("ESP Brainrot toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "ESP Timer Base", "F3", function()
    if timerEspToggle then
        timerEspToggle:Set(not timerEspToggle:Get())
        print("ESP Timer Base toggleado via keybind!")
    end
end)

-- Outros
createKeybindUI(keybindsTab, "Desync", "F4", function()
    if desyncToggle then
        desyncToggle:Set(not desyncToggle:Get())
        print("Desync toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "InfinfiniteJump", "F4", function()
    if infiniteJumpToggle then
        infiniteJumpToggle:Set(not infiniteJumpToggle:Get())
        print("infiniteJump toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Float Base", "F5", function()
    if floatToggle then
        floatToggle:Set(not floatToggle:Get())
        print("Float Base toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Auto Pull", "F5", function()
    if floatToggle then
        floatToggle:Set(not AutoPullToggle:Get())
        print("Auto Pull toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Travar Players", "F6", function()
    if travarToggle then
        travarToggle:Set(not travarToggle:Get())
        print("Travar Players toggleado via keybind!")
    end
end)

-- Servidor
createKeybindUI(keybindsTab, "Anti Bee", "F7", function()
    if antiBeeToggle then
        antiBeeToggle:Set(not antiBeeToggle:Get())
        print("Anti Bee toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Anti Lag", "F8", function()
    if antiLagToggle then
        antiLagToggle:Set(not antiLagToggle:Get())
        print("Anti Lag toggleado via keybind!")
    end
end)

-- Main
createKeybindUI(keybindsTab, "Aimbot Beta", "F9", function()
    if aimbotToggle then
        aimbotToggle:Set(not aimbotToggle:Get())
        print("Aimbot Beta toggleado via keybind!")
    end
end)

-- Botão para resetar todos os keybinds
GUI:CreateSection({
    parent = keybindsTab, 
    text = "Gerenciamento"
})

local resetButton = Instance.new("TextButton")
resetButton.Size = UDim2.new(0.8, 0, 0, 30)
resetButton.Position = UDim2.new(0.1, 0, 0, 0)
resetButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
resetButton.BorderSizePixel = 0
resetButton.Text = "Resetar Todos Keybinds"
resetButton.TextColor3 = Color3.fromRGB(255, 255, 255)
resetButton.TextSize = 12
resetButton.Font = Enum.Font.Gotham
resetButton.Parent = keybindsTab

resetButton.MouseButton1Click:Connect(function()
    -- Deleta o arquivo de salvamento
    local success = pcall(function()
        delfile(KeybindSystem.SaveFile)
    end)
    
    -- Recarrega a interface
    for name, element in pairs(keybindElements) do
        if element.button then
            local defaultKey = ""
            if name == "ESP Inimigos" then defaultKey = "F1"
            elseif name == "ESP Brainrot" then defaultKey = "F2"
            elseif name == "ESP Timer Base" then defaultKey = "F3"
            elseif name == "Desync" then defaultKey = "F4"
            elseif name == "Float Base" then defaultKey = "F5"
            elseif name == "Travar Players" then defaultKey = "F6"
            elseif name == "Anti Bee" then defaultKey = "F7"
            elseif name == "Anti Lag" then defaultKey = "F8"
            elseif name == "Aimbot Beta" then defaultKey = "F9"
            end
            
            KeybindSystem:UpdateKeybind(name, defaultKey)
            element.button.Text = defaultKey
        end
    end
    
    print("Todos os keybinds foram resetados para padrão!")
end)

-- Seção de informações
GUI:CreateSection({
    parent = keybindsTab, 
    text = "Instruções"
})

-- Texto informativo
local infoLabel = Instance.new("TextLabel")
infoLabel.Size = UDim2.new(1, 0, 0, 100)
infoLabel.Position = UDim2.new(0, 0, 0, 0)
infoLabel.BackgroundTransparency = 1
infoLabel.Text = "Sistema de Keybinds com Salvamento:\n• Clique no botão do keybind\n• Pressione a tecla desejada\n• As keybinds são salvas automaticamente\n• Funcionam após reinjetar o script\n• Use o botão vermelho para resetar\n\nArquivo: Ashlabs_Keybinds.txt"
infoLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
infoLabel.TextSize = 12
infoLabel.TextWrapped = true
infoLabel.TextXAlignment = Enum.TextXAlignment.Left
infoLabel.Font = Enum.Font.Gotham
infoLabel.Parent = keybindsTab

-- Notificação de keybinds carregados
print("=== SISTEMA DE KEYBINDS CARREGADO ===")
print("Arquivo de salvamento: " .. KeybindSystem.SaveFile)

-- Verifica se carregou keybinds salvos
local savedKeybinds = KeybindSystem:LoadKeybinds()
if savedKeybinds then
    print("Keybinds anteriores carregados com sucesso!")
    for name, key in pairs(savedKeybinds) do
        print("- " .. name .. ": " .. key)
    end
else
    print("Usando keybinds padrão (F1-F9)")
end

print("=====================================")

-- Carrega o Notfly automaticamente
local function loadNotfly()
    local success, err = pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/teuzzjheyt/Notfly/refs/heads/main/Notfly",true))()
    end)
    if not success then
        warn("Erro ao carregar o script Notfly:", err)
    else
        print("Script Notfly carregado com sucesso!")
    end
end

loadNotfly()

-- Verificar e habilitar memory tracking de forma segura
if not stats then
    print("Stats não disponível neste ambiente")
else
    if not stats.MemoryTrackingEnabled then
        stats.MemoryTrackingEnabled = true
    end
    
    -- Esperar um pouco para inicializar
    wait(0.1)
    
    -- Usar pcall para evitar erros
    local success, memoryStats = pcall(function()
        return stats("Memory")
    end)
    
    if success and memoryStats then
        print("Memory heap:", memoryStats.heap)
    else
        print("Não foi possível acessar estatísticas de memória")
    end
end
