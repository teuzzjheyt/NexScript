local GUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/teuzzjheyt/Ash-Nex/refs/heads/main/Ash%20Main"))()

GUI:CreateMain({
    Name = "Ashlabs",
    title = "Nex Hub",
    ToggleUI = "LeftControl",
    WindowIcon = "home",
    Theme = {
    Background = Color3.fromRGB(10, 10, 10),       -- Preto quase puro
    Secondary = Color3.fromRGB(20, 20, 20),        -- Preto escuro
    Accent = Color3.fromRGB(255, 40, 40),          -- Vermelho intenso
    Text = Color3.fromRGB(255, 255, 255),          -- Texto branco
    TextSecondary = Color3.fromRGB(180, 180, 180), -- Texto cinza
    Border = Color3.fromRGB(50, 50, 50),           -- Bordas cinza
    NavBackground = Color3.fromRGB(5, 5, 5)        -- Preto mais escuro para navegação
     },
    Blur = {
        Enable = false,        -- Ativa o blur no fundo
        value = 0.3           -- Intensidade do blur
    },
    Config = {
        Enabled = false,
    }
})

-- Sistema de Keybinds Global com Salvamento
local KeybindSystem = {
    Keybinds = {},
    Connections = {},
    SaveFile = "Ashlabs_Keybinds.txt"
}

-- Função para salvar keybinds no arquivo
function KeybindSystem:SaveKeybinds()
    local saveData = {}
    for name, keybindData in pairs(self.Keybinds) do
        saveData[name] = keybindData.key
    end
    
    local jsonData = game:GetService("HttpService"):JSONEncode(saveData)
    
    local success, err = pcall(function()
        writefile(self.SaveFile, jsonData)
    end)
    
    if success then
        print("Keybinds salvos com sucesso!")
    else
        warn("Erro ao salvar keybinds:", err)
    end
end

-- Função para carregar keybinds do arquivo
function KeybindSystem:LoadKeybinds()
    local success, fileData = pcall(function()
        return readfile(self.SaveFile)
    end)
    
    if success and fileData then
        local success2, savedData = pcall(function()
            return game:GetService("HttpService"):JSONDecode(fileData)
        end)
        
        if success2 and savedData then
            return savedData
        end
    end
    return nil
end

-- Função para registrar um keybind
function KeybindSystem:RegisterKeybind(name, defaultKey, callback)
    -- Primeiro tenta carregar do arquivo salvo
    local savedKeybinds = self:LoadKeybinds()
    local actualKey = defaultKey
    
    if savedKeybinds and savedKeybinds[name] then
        actualKey = savedKeybinds[name]
        print("Keybind carregado: " .. name .. " = " .. actualKey)
    end
    
    self.Keybinds[name] = {
        key = actualKey,
        callback = callback,
        enabled = true
    }
    return self.Keybinds[name]
end

-- Função para atualizar um keybind
function KeybindSystem:UpdateKeybind(name, newKey)
    if self.Keybinds[name] then
        self.Keybinds[name].key = newKey
        -- Salva automaticamente quando atualiza
        self:SaveKeybinds()
    end
end

-- Sistema de input
local UserInputService = game:GetService("UserInputService")

-- Conexão principal para detectar keybinds
KeybindSystem.Connections.main = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.UserInputType == Enum.UserInputType.Keyboard then
        local key = input.KeyCode.Name
        
        for name, keybindData in pairs(KeybindSystem.Keybinds) do
            if keybindData.enabled and keybindData.key == key then
                keybindData.callback()
                break
            end
        end
    end
end)

-- Variáveis para os toggles que serão controlados por keybinds
local aimbotToggle, espToggle, brainrotEspToggle, timerEspToggle, desyncToggle, floatToggle, travarToggle, antiBeeToggle, antiLagToggle

local main = GUI:CreateTab("Main", "home")

GUI:CreateSection({
    parent = main, 
    text = "Main"
})

-- Variáveis globais fora do toggle
local auto_enabled = false
local auto_connection = nil
local current_tool_equipped = nil
local current_auto_type = nil

-- Configurações para cada tipo de ferramenta
local tool_configs = {
    web_slinger = {
        tool_name = "Web Slinger",
        remote_names = {
            "RE/UseItem",
            "UseItem", 
            "UseTool"
        },
        max_distance = 100
    },
    laser_cape = {
        tool_name = "Laser Cape", 
        remote_names = {
            "RE/UseItem",
            "UseItem",
            "UseTool"
        },
        max_distance = 50
    }
}

aimbotToggle = GUI:CreateToggle({
    parent = main, 
    text = "Aimbot Beta", 
    desc = "Sistema automático para Web Slinger e Laser Cape. Detecta inimigos e atira automaticamente.", 
    default = false, 
    callback = function(state)
        print("Aimbot state:", state)
        
        local player = game:GetService("Players").LocalPlayer
        local replicated_storage = game:GetService("ReplicatedStorage")
        local players = game:GetService("Players")
        local run_service = game:GetService("RunService")

        -- Função para detectar qual ferramenta está equipada
        local function detect_current_tool()
            local char = player.Character
            if not char then return nil end
            
            local current_tool = char:FindFirstChildOfClass('Tool')
            if not current_tool then return nil end
            
            for tool_type, config in pairs(tool_configs) do
                if current_tool.Name == config.tool_name then
                    return tool_type, current_tool
                end
            end
            
            return nil, current_tool
        end

        -- Função para encontrar o remote correto
        local function find_remote(tool_type)
            local config = tool_configs[tool_type]
            if not config then return nil end
            
            for _, remote_name in ipairs(config.remote_names) do
                local remote = replicated_storage:FindFirstChild('Packages') and replicated_storage.Packages:FindFirstChild('Net') and replicated_storage.Packages.Net:FindFirstChild(remote_name)
                if not remote then
                    remote = replicated_storage:FindFirstChild('Events') and replicated_storage.Events:FindFirstChild(remote_name)
                end
                if not remote then
                    remote = replicated_storage:FindFirstChild('Remotes') and replicated_storage.Remotes:FindFirstChild(remote_name)
                end
                if remote then
                    return remote
                end
            end
            
            return nil
        end

        -- Função de atirar/usar ferramenta
        local function use_tool()
            if not current_auto_type then return end
            
            local char = player.Character
            local hum = char and char:FindFirstChildOfClass('Humanoid')
            local remote = find_remote(current_auto_type)

            if not (hum and hum.Health > 0 and remote and current_tool_equipped) then
                return
            end

            local my_hrp = char:FindFirstChild('HumanoidRootPart')
            if my_hrp then
                local config = tool_configs[current_auto_type]
                local max_distance = config.max_distance
                local closest_dist, target_part = max_distance, nil
                
                for _, p in ipairs(players:GetPlayers()) do
                    if p ~= player and p.Character then
                        local target_hum = p.Character:FindFirstChildOfClass('Humanoid')
                        local target_torso = p.Character:FindFirstChild('UpperTorso') or p.Character:FindFirstChild('Torso')
                        local target_hrp = p.Character:FindFirstChild('HumanoidRootPart')
                        local target_head = p.Character:FindFirstChild('Head')
                        
                        if target_hum and target_hum.Health > 0 and target_hrp then
                            local dist = (my_hrp.Position - target_hrp.Position).Magnitude
                            if dist < closest_dist then
                                closest_dist = dist
                                target_part = target_torso or target_hrp or target_head
                            end
                        end
                    end
                end
                
                if target_part then
                    remote:FireServer(target_part.Position, target_part)
                end
            end
        end

        -- Função principal do auto tool
        local function do_auto_tool_cycle()
            if not auto_enabled then return end
            
            if not current_auto_type then
                local detected_type, tool = detect_current_tool()
                if detected_type then
                    current_auto_type = detected_type
                    current_tool_equipped = tool
                else
                    return
                end
            end
            
            use_tool()
        end

        -- Controlar baseado no estado do toggle
        auto_enabled = state
        
        if state then
            -- Ligar
            if auto_connection then
                auto_connection:Disconnect()
            end
            
            -- Detectar ferramenta atual
            local detected_type, tool = detect_current_tool()
            if detected_type then
                current_auto_type = detected_type
                current_tool_equipped = tool
                print("🟢 Auto Tool LIGADO - " .. tool_configs[detected_type].tool_name)
            else
                print("⚠️ Auto Tool LIGADO - Equipe Web Slinger ou Laser Cape")
            end
            
            auto_connection = run_service.Heartbeat:Connect(do_auto_tool_cycle)
        else
            -- Desligar
            if auto_connection then
                auto_connection:Disconnect()
                auto_connection = nil
            end
            print("🔴 Auto Tool DESLIGADO")
        end
    end
})

-- Monitorar mudanças de ferramenta (apenas uma vez)
local run_service = game:GetService("RunService")
local player = game:GetService("Players").LocalPlayer

run_service.Heartbeat:Connect(function()
    if not auto_enabled then return end
    
    local detected_type, tool = detect_current_tool()
    
    if detected_type then
        if current_auto_type ~= detected_type then
            current_auto_type = detected_type
            current_tool_equipped = tool
            print("🔄 Ferramenta detectada: " .. tool_configs[detected_type].tool_name)
        end
    else
        if current_auto_type then
            current_auto_type = nil
            current_tool_equipped = nil
            print("⚠️ Ferramenta não suportada - Auto Tool aguardando")
        end
    end
end)

GUI:CreateParagraph({
    parent = main,
    title = "Aimbot Beta",
    text = "Auto Aim with Laser Cape or single web."
})

GUI:CreateToggle({
    parent = main, 
    text = "Toggle Me", 
    default = false, 
    callback = function(state)
        print("Toggle state:", state)
    end
})

GUI:CreateToggle({
    parent = main, 
    text = "Toggle Me", 
    default = false, 
    callback = function(state)
        print("Toggle state:", state)
    end
})

local visual = GUI:CreateTab("Visual", "eye")

GUI:CreateSection({
    parent = visual, 
    text = "Visual"
})


espToggle = GUI:CreateToggle({
    parent = visual,
    text = "Esp Inimigos",
    default = true,
    callback = function(state)
        _G.IsEspPlayerEnabled = state

        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local CoreGui = game:GetService("CoreGui")
        local Camera = game:GetService("Workspace").CurrentCamera
        local localPlayer = Players.LocalPlayer

        local espSettings = {
            enabled = state,
            maxDistance = 2000,
            forceMaterial = true,
            forceTransparency = 0.5,
            outlineEnabled = true,
            glowEnabled = true,
            nameTagEnabled = true,
            nameTagSize = 14,
            nameTagColor = Color3.fromRGB(0, 255, 255),
            checkInterval = 0.5,
            playerColor = Color3.fromRGB(0, 255, 255),
        }

        local espData = {}
        local playerConnections = {}
        local nameTags = {}
        local monitorThread = nil

        local function forcePartVisibility(part)
            if not part then return end
            part.LocalTransparencyModifier = 0
            part.CastShadow = true
            if espSettings.forceMaterial then
                part.Material = Enum.Material.ForceField
                part.Transparency = espSettings.forceTransparency
            end
        end

        local function updateNameTag(player, character)
            if not espSettings.nameTagEnabled or not character or not character:FindFirstChild("HumanoidRootPart") then return end
            local humanoidRootPart = character.HumanoidRootPart
            if nameTags[player] then nameTags[player]:Destroy() nameTags[player] = nil end

            local billboard = Instance.new("BillboardGui")
            billboard.Name = "FixedNameESP"
            billboard.Adornee = humanoidRootPart
            billboard.Size = UDim2.new(0, 200, 0, 50)
            billboard.StudsOffset = Vector3.new(0, 2.5, 0)
            billboard.AlwaysOnTop = true
            billboard.MaxDistance = espSettings.maxDistance
            billboard.Parent = CoreGui

            local nameLabel = Instance.new("TextLabel")
            nameLabel.Size = UDim2.new(1, 0, 1, 0)
            nameLabel.Text = player.Name
            nameLabel.TextColor3 = espSettings.nameTagColor
            nameLabel.TextSize = espSettings.nameTagSize
            nameLabel.Font = Enum.Font.SourceSansBold
            nameLabel.BackgroundTransparency = 1
            nameLabel.TextStrokeTransparency = 0.5
            nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            nameLabel.Parent = billboard

            nameTags[player] = billboard

            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.Died:Connect(function()
                    if nameTags[player] then
                        nameTags[player]:Destroy()
                        nameTags[player] = nil
                    end
                end)
            end
        end

        local function cleanPlayerEsp(player)
            if espData[player] then
                for _, conn in pairs(espData[player].connections) do
                    conn:Disconnect()
                end
                if espData[player].highlight then espData[player].highlight:Destroy() end
                espData[player] = nil
            end
            if nameTags[player] then
                nameTags[player]:Destroy()
                nameTags[player] = nil
            end
        end

        local function applyEsp(player, character)
            if not character then return end
            cleanPlayerEsp(player)

            espData[player] = {parts = {}, connections = {}}

            local function processPart(part)
                if part:IsA("BasePart") or part:IsA("MeshPart") or part:IsA("Part") then
                    forcePartVisibility(part)
                    local conn = part:GetPropertyChangedSignal("Transparency"):Connect(function()
                        forcePartVisibility(part)
                    end)
                    table.insert(espData[player].connections, conn)
                end
            end

            for _, part in pairs(character:GetDescendants()) do
                processPart(part)
            end

            local descendantAddedConn = character.DescendantAdded:Connect(function(part)
                processPart(part)
            end)
            table.insert(espData[player].connections, descendantAddedConn)

            if espSettings.glowEnabled then
                local highlight = Instance.new("Highlight")
                highlight.Name = "UniversalESPHighlight"
                highlight.Adornee = character
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.FillColor = espSettings.playerColor
                highlight.OutlineColor = espSettings.playerColor
                highlight.FillTransparency = 0.3
                highlight.Parent = CoreGui
                espData[player].highlight = highlight
            end

            if espSettings.nameTagEnabled then
                updateNameTag(player, character)
            end

            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local diedConn = humanoid.Died:Connect(function()
                    if nameTags[player] then
                        nameTags[player]:Destroy()
                        nameTags[player] = nil
                    end
                    delay(3, function()
                        if player.Character and _G.IsEspPlayerEnabled then
                            applyEsp(player, player.Character)
                        end
                    end)
                end)
                table.insert(espData[player].connections, diedConn)
            end
        end

        local function removeEsp(player)
            cleanPlayerEsp(player)
            if playerConnections[player] then
                for _, conn in pairs(playerConnections[player]) do
                    conn:Disconnect()
                end
                playerConnections[player] = nil
            end
        end

        local function monitorAllPlayers()
            while _G.IsEspPlayerEnabled do
                wait(espSettings.checkInterval)
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= localPlayer then
                        local character = player.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local distance = 0
                            if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                distance = (character.HumanoidRootPart.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
                            end
                            if distance <= espSettings.maxDistance or distance == 0 then
                                if not espData[player] or espData[player].character ~= character then
                                    applyEsp(player, character)
                                    espData[player].character = character
                                end
                            else
                                removeEsp(player)
                            end
                        else
                            removeEsp(player)
                        end
                    end
                end
            end
            for player, _ in pairs(espData) do
                removeEsp(player)
            end
        end

        local function setupAutoReconnect()
            for player, connections in pairs(playerConnections) do
                for _, conn in pairs(connections) do
                    conn:Disconnect()
                end
            end
            playerConnections = {}

            for _, player in pairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    playerConnections[player] = {}
                    local charAddedConn = player.CharacterAdded:Connect(function(character)
                        if _G.IsEspPlayerEnabled then
                            wait(2)
                            applyEsp(player, character)
                        end
                    end)
                    table.insert(playerConnections[player], charAddedConn)
                    local charRemovingConn = player.CharacterRemoving:Connect(function()
                        cleanPlayerEsp(player)
                    end)
                    table.insert(playerConnections[player], charRemovingConn)
                    if player.Character and _G.IsEspPlayerEnabled then
                        applyEsp(player, player.Character)
                    end
                end
            end

            Players.PlayerAdded:Connect(function(player)
                if player ~= localPlayer then
                    playerConnections[player] = {}
                    local charAddedConn = player.CharacterAdded:Connect(function(character)
                        if _G.IsEspPlayerEnabled then
                            wait(2)
                            applyEsp(player, character)
                        end
                    end)
                    table.insert(playerConnections[player], charAddedConn)
                    local charRemovingConn = player.CharacterRemoving:Connect(function()
                        cleanPlayerEsp(player)
                    end)
                    table.insert(playerConnections[player], charRemovingConn)
                end
            end)
        end

        if state then
            setupAutoReconnect()
            monitorThread = task.spawn(monitorAllPlayers)
            print("ESP Inimigos Ativado!")
        else
            _G.IsEspPlayerEnabled = false
            for _, player in pairs(Players:GetPlayers()) do
                removeEsp(player)
            end
            for player, connections in pairs(playerConnections) do
                for _, conn in pairs(connections) do
                    conn:Disconnect()
                end
            end
            playerConnections = {}
            monitorThread = nil
            print("ESP Inimigos Desativado!")
        end
    end
})

-- ESP Brainrot Corrigido
brainrotEspToggle = GUI:CreateToggle({
    parent = visual,
    text = "Esp Melhor Brainrot",
    default = true,
    callback = function(state)
        _G.IsBrainrotEspEnabled = state

        local workspace = game:GetService("Workspace")
        local Players = game:GetService("Players")
        local localPlayer = Players.LocalPlayer

        -- Funções auxiliares
        local function getMyPlot()
            local plots = workspace:FindFirstChild("Plots")
            if not plots then return nil end
            
            for _, plot in ipairs(plots:GetChildren()) do
                local plotSign = plot:FindFirstChild("PlotSign")
                if plotSign then
                    local yourBase = plotSign:FindFirstChild("YourBase")
                    if yourBase and yourBase.Enabled then
                        return plot
                    end
                end
            end
            return nil
        end

        local function parseValue(str)
            if not str then return 0 end
            local cleanStr = string.gsub(str, "/s", "")
            local num, suffix = string.match(cleanStr, "[$]?[%s]*([%d%.]+)[%s]*([MKBT]?)")
            if not num then return 0 end
            num = tonumber(num)
            if not num then return 0 end
            if suffix == "K" then num = num * 1e3
            elseif suffix == "M" then num = num * 1e6
            elseif suffix == "B" then num = num * 1e9
            elseif suffix == "T" then num = num * 1e12 end
            return num
        end

        local function isRaceTrackObject(obj)
            local parent = obj.Parent
            while parent do
                local nameLower = parent.Name:lower()
                if string.find(nameLower, "race") or string.find(nameLower, "track") or string.find(nameLower, "obstacle") then
                    return true
                end
                parent = parent.Parent
            end
            local nameLower = obj.Name:lower()
            return string.find(nameLower, "brainrot") or string.find(nameLower, "obstacle") or string.find(nameLower, "race") or string.find(nameLower, "track")
        end

        local function isInFuseMachine(obj)
            local parent = obj.Parent
            while parent do
                local nameLower = parent.Name:lower()
                if string.find(nameLower, "fuse") or string.find(nameLower, "infuse") or string.find(nameLower, "machine") then
                    return true
                end
                parent = parent.Parent
            end
            return false
        end

        local function isInMyBase(obj, myPlot)
            if not myPlot then return false end
            
            local currentParent = obj.Parent
            while currentParent do
                if currentParent == myPlot then
                    return true
                end
                currentParent = currentParent.Parent
            end
            return false
        end

        local function detectMutation(animalModel)
            -- Procurar por TextLabels que estão acima do nome principal
            local textLabels = {}
            
            for _, gui in ipairs(animalModel:GetDescendants()) do
                if gui:IsA("TextLabel") then
                    table.insert(textLabels, gui)
                end
            end
            
            -- Ordenar por posição Y (os mais altos primeiro)
            table.sort(textLabels, function(a, b)
                return a.Position.Y.Scale > b.Position.Y.Scale
            end)
            
            -- Mutações (GOLD removido)
            local mutations = {
                "DIAMOND", "RAINBOW", "GALAXY", 
                "LAVA", "BLOODROT", "CANDY", "YIN YANG",
                "YING YANG", "YIN", "YANG", "YING"
            }
            
            for _, label in ipairs(textLabels) do
                local text = label.Text
                if text then
                    local textUpper = text:upper()
                    -- Verificar correspondência exata
                    for _, mutation in ipairs(mutations) do
                        if textUpper == mutation then
                            return mutation
                        end
                    end
                    
                    -- Verificar se contém "yin" ou "yang"
                    if string.find(textUpper, "YIN") or string.find(textUpper, "YANG") then
                        return "YIN YANG"
                    end
                end
            end
            
            return "NORMAL"
        end

        -- MÉTODO: Busca em Billboards (AnimalOverhead direto)
        local function findBestBrainrot_Billboards()
            local best = { animalModel = nil, name = "", valueStr = "", valueNum = 0, mutation = "NORMAL" }
            local myPlot = getMyPlot()
            
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj.Name == "AnimalOverhead" and obj:IsA("BillboardGui") then
                    local displayName = obj:FindFirstChild("DisplayName")
                    local generation = obj:FindFirstChild("Generation")
                    
                    if displayName and generation then
                        -- Encontrar o animal model associado
                        local animalModel = obj.Parent
                        while animalModel and not animalModel:IsA("Model") do
                            animalModel = animalModel.Parent
                        end
                        
                        -- Verificar se não está na minha base, fuse machine ou race track
                        if animalModel and not isInMyBase(animalModel, myPlot) and not isInFuseMachine(animalModel) and not isRaceTrackObject(animalModel) then
                            local valueNum = parseValue(generation.Text)
                            if valueNum > best.valueNum then
                                best.valueNum = valueNum
                                best.valueStr = generation.Text
                                best.name = displayName.Text
                                best.animalModel = animalModel
                                best.mutation = detectMutation(animalModel)
                            end
                        end
                    end
                end
            end
            return best
        end

        -- ESP Functions
        local function clearESP()
            if _G.LastBrainrotESP and _G.LastBrainrotESP.Parent then
                _G.LastBrainrotESP:Destroy()
                _G.LastBrainrotESP = nil
            end
            if _G.LastBrainrotHighlight and _G.LastBrainrotHighlight.Parent then
                _G.LastBrainrotHighlight:Destroy()
                _G.LastBrainrotHighlight = nil
            end
        end

        local function highlightAnimal(animalModel)
            if _G.LastBrainrotHighlight and _G.LastBrainrotHighlight.Parent then
                _G.LastBrainrotHighlight:Destroy()
            end
            if animalModel then
                local highlight = Instance.new("Highlight")
                highlight.Name = "BrainrotHighlight"
                highlight.FillColor = Color3.fromRGB(255, 0, 255)
                highlight.FillTransparency = 0.6
                highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
                highlight.OutlineTransparency = 0
                highlight.Adornee = animalModel
                highlight.Parent = animalModel
                _G.LastBrainrotHighlight = highlight
            end
        end

        local function createESP(animalModel, name, value, mutation)
            local rootPart = animalModel:FindFirstChild("HumanoidRootPart") or animalModel:FindFirstChild("Head") or animalModel:FindFirstChild("Torso") or animalModel:FindFirstChildWhichIsA("Part")
            local adornee = rootPart or animalModel

            local attachment = Instance.new("Attachment")
            attachment.Name = "BrainrotESPAttachment"
            attachment.Parent = adornee

            -- ESP Billboard: 400 x 120 pixels
            local esp = Instance.new("BillboardGui")
            esp.Name = "BrainrotESP"
            esp.Size = UDim2.new(0, 400, 0, 120)
            esp.Adornee = attachment
            esp.AlwaysOnTop = true  -- Sempre no topo
            esp.MaxDistance = 2000
            esp.ExtentsOffset = Vector3.new(0, 5, 0)  -- 5 unidades acima do animal
            esp.Parent = attachment

            -- Container: 100% do tamanho da Billboard
            local container = Instance.new("Frame")
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1
            container.Parent = esp

            -- 1 - Mutação (primeira linha)
            local mutationLabel = Instance.new("TextLabel")
            mutationLabel.Size = UDim2.new(1, 0, 0.33, 0)
            mutationLabel.Position = UDim2.new(0, 0, 0, 0)
            mutationLabel.BackgroundTransparency = 1
            mutationLabel.BorderSizePixel = 0
            mutationLabel.TextStrokeTransparency = 0.2
            mutationLabel.TextSize = 18
            mutationLabel.Font = Enum.Font.GothamBold
            mutationLabel.Text = mutation
            mutationLabel.TextColor3 = Color3.new(1, 1, 1)  -- Branco
            mutationLabel.TextWrapped = true
            mutationLabel.Parent = container

            -- 2 - Nome do animal: 50% da altura, TextSize: 32
            local nameLabel = Instance.new("TextLabel")
            nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
            nameLabel.Position = UDim2.new(0, 0, 0.33, 0)
            nameLabel.BackgroundTransparency = 1
            nameLabel.BorderSizePixel = 0
            nameLabel.TextStrokeTransparency = 0.2
            nameLabel.TextSize = 32  -- Tamanho especificado
            nameLabel.Font = Enum.Font.GothamBold  -- Fonte especificada
            nameLabel.Text = name
            nameLabel.TextColor3 = Color3.new(1, 1, 0)  -- Amarelo
            nameLabel.TextWrapped = true
            nameLabel.Parent = container

            -- 3 - Valor/geração: 50% da altura, TextSize: 28
            local valueLabel = Instance.new("TextLabel")
            valueLabel.Size = UDim2.new(1, 0, 0.5, 0)
            valueLabel.Position = UDim2.new(0, 0, 0.83, 0)
            valueLabel.BackgroundTransparency = 1
            valueLabel.BorderSizePixel = 0
            valueLabel.TextStrokeTransparency = 0.2
            valueLabel.TextSize = 28  -- Tamanho especificado
            valueLabel.Font = Enum.Font.GothamBold  -- Fonte especificada
            valueLabel.Text = value
            valueLabel.TextColor3 = Color3.new(0, 1, 0)  -- Verde
            valueLabel.TextWrapped = true
            valueLabel.Parent = container

            return esp, attachment
        end

        local function showBestBrainrotESP()
            clearESP()
            local best = findBestBrainrot_Billboards()
            if best.name == "" or not best.animalModel then 
                return 
            end
            
            highlightAnimal(best.animalModel)
            _G.LastBrainrotESP, _G.LastBrainrotAttachment = createESP(best.animalModel, best.name, best.valueStr, best.mutation)
            
            print("Mutação: " .. best.mutation .. " | Nome: " .. best.name .. " | Valor: " .. best.valueStr)
        end

        -- Liga ou desliga ESP
        if state then
            _G.BrainrotEspLoop = task.spawn(function()
                while _G.IsBrainrotEspEnabled do
                    pcall(showBestBrainrotESP)
                    task.wait(3)
                end
            end)
        else
            if _G.BrainrotEspLoop then
                task.cancel(_G.BrainrotEspLoop)
                _G.BrainrotEspLoop = nil
            end
            clearESP()
        end
    end
})



-- ESP Timer Base Corrigido
timerEspToggle = GUI:CreateToggle({
    parent = visual, 
    text = "Esp Timer Base", 
    default = true, 
    callback = function(state)
        _G.IsEspTimerBaseEnabled = state

        -- Ativar ESP
        if state then
            -- Serviços
            local Players = game:GetService("Players")

            -- Função para criar o Billboard na base
            local function CreateESP(basePlot)
                if basePlot:FindFirstChild("BaseTimerESP") then
                    return basePlot:FindFirstChild("BaseTimerESP"):FindFirstChild("TextLabel"), basePlot:FindFirstChild("BaseTimerESP")
                end

                local billboard = Instance.new("BillboardGui")
                billboard.Size = UDim2.new(0, 200, 0, 50)
                billboard.AlwaysOnTop = true
                billboard.StudsOffset = Vector3.new(0, 5, 0)
                billboard.Name = "BaseTimerESP"

                local label = Instance.new("TextLabel", billboard)
                label.Size = UDim2.new(1, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.TextColor3 = Color3.fromRGB(255, 255, 255)
                label.TextStrokeTransparency = 0.2
                label.Font = Enum.Font.SourceSansBold
                label.TextScaled = true
                label.Text = "Carregando..."

                local part = basePlot:FindFirstChildWhichIsA("BasePart")
                if part then
                    billboard.Parent = part
                end

                return label, billboard
            end

            -- Função para achar RemainingTime da base
            local function FindRemainingTime(plot)
                for _, desc in pairs(plot:GetDescendants()) do
                    if desc:IsA("TextLabel") and desc.Name == "RemainingTime" then
                        return desc
                    end
                end
            end

            -- Cria ESP para todas as bases
            _G.BaseEspElements = {}
            for _, plot in pairs(workspace.Plots:GetChildren()) do
                local lbl, billboard = CreateESP(plot)
                _G.BaseEspElements[plot] = {Label = lbl, Billboard = billboard}
            end

            -- Loop de atualização
            _G.BaseEspLoop = task.spawn(function()
                while _G.IsEspTimerBaseEnabled do
                    task.wait(1)
                    for plot, uiElements in pairs(_G.BaseEspElements) do
                        if not plot or not plot.Parent or not uiElements.Label or not uiElements.Label.Parent then continue end
                        
                        local uiLabel = uiElements.Label
                        local timer = FindRemainingTime(plot)

                        if timer and timer.Text ~= "" then
                            local num = tonumber(timer.Text:match("%d+"))
                            if num and num > 0 then
                                uiLabel.Text = timer.Text
                                if num <= 10 then
                                    uiLabel.TextColor3 = Color3.fromRGB(255, 0, 0) -- vermelho
                                else
                                    uiLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- branco
                                end
                            else
                                uiLabel.Text = "Aberta"
                                uiLabel.TextColor3 = Color3.fromRGB(0, 255, 0) -- verde
                            end
                        else
                            uiLabel.Text = "Aberta"
                            uiLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
                        end
                    end
                end
            end)

        -- Desativar ESP
        else
            if _G.BaseEspElements then
                for _, uiElements in pairs(_G.BaseEspElements) do
                    if uiElements.Billboard and uiElements.Billboard.Parent then
                        uiElements.Billboard:Destroy()
                    end
                end
                _G.BaseEspElements = nil
            end
            if _G.BaseEspLoop then
                task.cancel(_G.BaseEspLoop)
                _G.BaseEspLoop = nil
            end
        end
    end
})


OwnerEspToggle = GUI:CreateToggle({
    parent = visual, 
    text = "Esp Owner Base", 
    default = true, 
    callback = function(state)
        _G.IsEspOwnerEnabled = state

        -- Ativar ESP
        if state then
            -- Serviços
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local Workspace = game:GetService("Workspace")
            local LocalPlayer = Players.LocalPlayer

            -- Variáveis do ESP
            _G.espObjects = {}

            -- Função para criar ESP SEM FUNDO COR ROXA
            local function createESP(plot, ownerName)
                if _G.espObjects[plot] then
                    _G.espObjects[plot]:Destroy()
                end
                
                -- Criar BillboardGui SEM FUNDO
                local billboard = Instance.new("BillboardGui")
                billboard.Name = "PlotESP"
                billboard.Size = UDim2.new(0, 400, 0, 60)
                billboard.StudsOffset = Vector3.new(0, 15, 0)
                billboard.AlwaysOnTop = true
                billboard.Active = true
                billboard.ClipsDescendants = false
                billboard.MaxDistance = 5000
                billboard.Enabled = true
                
                -- Criar texto ROXO SEM FUNDO
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1 -- FUNDO COMPLETAMENTE TRANSPARENTE
                textLabel.Text = ownerName
                textLabel.TextColor3 = Color3.fromRGB(170, 0, 255) -- COR ROXA
                textLabel.TextStrokeTransparency = 0.3 -- CONTORNO SUAVE
                textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
                textLabel.TextSize = 20
                textLabel.Font = Enum.Font.GothamBold
                textLabel.TextWrapped = false
                textLabel.Parent = billboard
                
                -- Colocar no Workspace
                billboard.Parent = Workspace
                
                -- Posicionar no plot
                local plotSign = plot:FindFirstChild("PlotSign")
                local plotPrimaryPart = plot:IsA("Model") and plot.PrimaryPart or plot:FindFirstChildWhichIsA("BasePart")
                
                if plotSign then
                    billboard.Adornee = plotSign
                elseif plotPrimaryPart then
                    billboard.Adornee = plotPrimaryPart
                else
                    billboard.Adornee = plot
                end
                
                _G.espObjects[plot] = billboard
                return billboard
            end

            -- MÉTODO ESPECIAL: Detectar e ignorar MEU nickname
            local function shouldIgnorePlot(plot)
                local plotSign = plot:FindFirstChild("PlotSign")
                if not plotSign then 
                    return false
                end
                
                for _, child in pairs(plotSign:GetDescendants()) do
                    if child:IsA("TextLabel") or child:IsA("TextButton") then
                        local text = child.Text or ""
                        if text ~= "" then
                            -- Verificar se algum texto é EXATAMENTE meu nickname
                            if text == LocalPlayer.Name then
                                return true
                            end
                            
                            -- Verificar se contém meu nickname em padrões
                            if text:find(LocalPlayer.Name) then
                                return true
                            end
                            
                            -- Verificar padrão "[MeuNome]'s Base"
                            if text:find("'s Base") then
                                local ownerName = text:match("^(.+)'s Base$")
                                if ownerName and ownerName == LocalPlayer.Name then
                                    return true
                                end
                            end
                            
                            -- Verificar padrão "de [MeuNome]"
                            if text:find("de ") then
                                local ownerName = text:match("de%s+(.+)")
                                if ownerName and ownerName == LocalPlayer.Name then
                                    return true
                                end
                            end
                        end
                    end
                end
                
                return false
            end

            -- Análise do PlotSign
            local function getPlotOwner(plot)
                -- PRIMEIRO: Verificar se devemos ignorar este plot (minha base)
                if shouldIgnorePlot(plot) then
                    return nil
                end
                
                local plotSign = plot:FindFirstChild("PlotSign")
                if not plotSign then 
                    return "Sem Dono"
                end
                
                -- Busca RÁPIDA pelos textos
                for _, child in pairs(plotSign:GetDescendants()) do
                    if child:IsA("TextLabel") or child:IsA("TextButton") then
                        local text = child.Text or ""
                        if text ~= "" then
                            -- Padrão 1: "[Nome]'s Base"
                            if text:find("'s Base") then
                                local ownerName = text:match("^(.+)'s Base$")
                                if ownerName and ownerName ~= LocalPlayer.Name then
                                    return ownerName
                                end
                            end
                            
                            -- Padrão 2: "Base de [Nome]"
                            if text:find("Base de") then
                                local ownerName = text:match("Base de%s+(.+)")
                                if ownerName then
                                    ownerName = ownerName:gsub("%*", ""):gsub("\n", " "):match("([%w_]+)")
                                    if ownerName and ownerName ~= LocalPlayer.Name then
                                        return ownerName
                                    end
                                end
                            end
                            
                            -- Verificar se é um nome de jogador direto (e não sou eu)
                            for _, player in ipairs(Players:GetPlayers()) do
                                if text == player.Name and player ~= LocalPlayer then
                                    return player.Name
                                end
                            end
                            
                            -- Texto alternativo (desde que não seja meu nome)
                            if text ~= "YOUR BASE" and text ~= "Sem Dono" and text ~= "Semi Dono" and not text:find("INHEIRO") and text ~= LocalPlayer.Name then
                                if text:find("'s Base") then
                                    local ownerName = text:match("^(.+)'s Base$")
                                    if ownerName and ownerName ~= LocalPlayer.Name then
                                        return ownerName
                                    end
                                end
                                return text
                            end
                        end
                    end
                end
                
                return "Sem Dono"
            end

            -- Função principal do ESP
            local function updateESP()
                local plots = Workspace:FindFirstChild("Plots")
                if not plots then 
                    return 
                end
                
                for _, plot in ipairs(plots:GetChildren()) do
                    if plot:IsA("Model") or plot:IsA("Part") then
                        local ownerName = getPlotOwner(plot)
                        
                        if ownerName and ownerName ~= "Sem Dono" then
                            createESP(plot, ownerName)
                        else
                            -- Se for minha base ou sem dono, remover ESP se existir
                            if _G.espObjects[plot] then
                                _G.espObjects[plot]:Destroy()
                                _G.espObjects[plot] = nil
                            end
                        end
                    end
                end
            end

            -- Loop de atualização
            _G.EspOwnerLoop = task.spawn(function()
                while _G.IsEspOwnerEnabled do
                    updateESP()
                    task.wait(2) -- Atualiza a cada 2 segundos (otimizado)
                end
            end)



        -- Desativar ESP
        else
            if _G.espObjects then
                for plot, espObject in pairs(_G.espObjects) do
                    if espObject and espObject.Parent then
                        espObject:Destroy()
                    end
                end
                _G.espObjects = nil
            end
            
            if _G.EspOwnerLoop then
                task.cancel(_G.EspOwnerLoop)
                _G.EspOwnerLoop = nil
            end
            
            
        end
    end
})

local outros = GUI:CreateTab("Outros", "shield")

GUI:CreateSection({
    parent = outros, 
    text = "Outros"
})

desyncToggle = GUI:CreateToggle({
    parent = outros, 
    text = "Desync",
    default = true, 
    callback = function(state)
        if state then
            local url = "https://raw.githubusercontent.com/teuzzjheyt/Desync/refs/heads/main/Desync"
            local success, err = pcall(function()
                local scriptContent = game:HttpGet(url, true)
                loadstring(scriptContent)()
                
                -- Aguarda um pouco e tenta forçar a interface
                wait(2)
                -- Tenta encontrar e ativar a interface do Desync
                pcall(function()
                    if DesyncMain then
                        DesyncMain.Visible = true
                    end
                end)
            end)
            if not success then
                warn("Erro ao injetar a script Desync:", err)
            end
        end
    end
})

floatToggle = GUI:CreateToggle({
    parent = outros, 
    text = "Float Base",
    default = true, 
    callback = function(state)
        if state then
            local url = "https://raw.githubusercontent.com/teuzzjheyt/Float-Base/refs/heads/main/Floatbase"
            local success, err = pcall(function()
                loadstring(game:HttpGet(url, true))()
            end)
            if not success then
                warn("Erro ao injetar a script Desync:", err)
            end
        end
    end
})

-- Variáveis globais para o Infinite Jump
local infiniteJumpEnabled = false
local renderSteppedConnection = nil
local characterAddedConnection = nil

infiniteJumpToggle = GUI:CreateToggle({
    parent = outros, 
    text = "Infinite Jump",
    default = false, 
    callback = function(state)
        local LocalPlayer = game:GetService("Players").LocalPlayer
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")
        
        if state then
            -- Ativar Infinite Jump
            infiniteJumpEnabled = true
            
            local function enableInfiniteJump()
                if renderSteppedConnection then
                    renderSteppedConnection:Disconnect()
                    renderSteppedConnection = nil
                end

                renderSteppedConnection = RunService.RenderStepped:Connect(function()
                    local character = LocalPlayer.Character
                    if not character then return end
                    
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    
                    if humanoidRootPart and humanoid and infiniteJumpEnabled then
                        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                            humanoidRootPart.Velocity = Vector3.new(
                                humanoidRootPart.Velocity.X,
                                40, -- Força do pulo
                                humanoidRootPart.Velocity.Z
                            )
                        end
                    end
                end)
            end

            -- Configurar reconexão quando o personagem morrer/renascer
            if characterAddedConnection then
                characterAddedConnection:Disconnect()
            end
            
            characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(character)
                if infiniteJumpEnabled then
                    wait(1)
                    enableInfiniteJump()
                end
            end)

            -- Ativar inicialmente
            enableInfiniteJump()

        else
            -- Desativar Infinite Jump
            infiniteJumpEnabled = false
            
            if renderSteppedConnection then
                renderSteppedConnection:Disconnect()
                renderSteppedConnection = nil
            end
            
            if characterAddedConnection then
                characterAddedConnection:Disconnect()
                characterAddedConnection = nil
            end
        end
    end
})
travarToggle = GUI:CreateToggle({
    parent = outros, 
    text = "Travar Players", 
    default = true,
    callback = function(state)
        if state then
            local url = "https://raw.githubusercontent.com/teuzzjheyt/Nxreducefps/refs/heads/main/Nxreducefps.lua"
            local success, err = pcall(function()
                loadstring(game:HttpGet(url, true))()
            end)
            if not success then
                warn("Erro ao injetar a script:", err)
            end
        end
    end
})

GUI:CreateToggle({
    parent = outros, 
    text = "Steal floor",
    default = true,
    callback = function(state)
        if state then
            local url = "https://raw.githubusercontent.com/teuzzjheyt/3rd-flor/refs/heads/main/3rdflor"
            
            local success, err = pcall(function()
                loadstring(game:HttpGet(url, true))()
            end)
            
            if not success then
                warn("Erro ao injetar a script 3D Floor:", err)
            end
        end
    end
})

-- Variáveis globais para manter o estado
local spammerVariables = {
    visiblePrompts = {},
    isSpammerActive = false,
    spammerLoop = nil,
    connections = {}
}

-- Toggle para o Proximity Prompt Spammer
GUI:CreateToggle({
    parent = outros,
    text = "Auto Pull",
    callback = function(state)
        local Players = game:GetService('Players')
        
        local function addVisiblePrompt(prompt)
            if prompt and prompt:IsA('ProximityPrompt') then
                if not table.find(spammerVariables.visiblePrompts, prompt) then
                    table.insert(spammerVariables.visiblePrompts, prompt)
                end
            end
        end

        local function removeVisiblePrompt(prompt)
            for i, p in ipairs(spammerVariables.visiblePrompts) do
                if p == prompt then
                    table.remove(spammerVariables.visiblePrompts, i)
                    break
                end
            end
        end

        local function setupPromptEvents()
            -- Limpar conexões anteriores
            for _, connection in ipairs(spammerVariables.connections) do
                connection:Disconnect()
            end
            table.clear(spammerVariables.connections)
            
            -- Configurar eventos para prompts existentes
            for _, prompt in pairs(game:GetDescendants()) do
                if prompt:IsA('ProximityPrompt') then
                    local conn1 = prompt.PromptShown:Connect(function()
                        addVisiblePrompt(prompt)
                    end)
                    local conn2 = prompt.PromptHidden:Connect(function()
                        removeVisiblePrompt(prompt)
                    end)
                    table.insert(spammerVariables.connections, conn1)
                    table.insert(spammerVariables.connections, conn2)
                end
            end

            -- Configurar evento para novos prompts
            local descendantAddedConn = game.DescendantAdded:Connect(function(descendant)
                if descendant:IsA('ProximityPrompt') then
                    local conn1 = descendant.PromptShown:Connect(function()
                        addVisiblePrompt(descendant)
                    end)
                    local conn2 = descendant.PromptHidden:Connect(function()
                        removeVisiblePrompt(descendant)
                    end)
                    table.insert(spammerVariables.connections, conn1)
                    table.insert(spammerVariables.connections, conn2)
                end
            end)
            table.insert(spammerVariables.connections, descendantAddedConn)
        end

        local function triggerWithHold(prompt, holdTime)
            holdTime = holdTime or 0.5
            fireproximityprompt(prompt)
            prompt:InputHoldBegin()
            wait(holdTime)
            prompt:InputHoldEnd()
        end

        local function startSpammer(interval)
            interval = interval or 1
            spammerVariables.spammerLoop = task.spawn(function()
                while spammerVariables.isSpammerActive do
                    for _, prompt in ipairs(spammerVariables.visiblePrompts) do
                        if prompt and prompt.Parent and spammerVariables.isSpammerActive then
                            triggerWithHold(prompt, 0.5)
                        end
                    end
                    task.wait(interval)
                end
            end)
        end

        local function stopSpammer()
            spammerVariables.isSpammerActive = false
            if spammerVariables.spammerLoop then
                task.cancel(spammerVariables.spammerLoop)
                spammerVariables.spammerLoop = nil
            end
            
            -- Limpar todas as conexões
            for _, connection in ipairs(spammerVariables.connections) do
                connection:Disconnect()
            end
            table.clear(spammerVariables.connections)
            
            -- Limpar a lista de prompts visíveis
            table.clear(spammerVariables.visiblePrompts)
        end

        -- Executar baseado no estado do toggle
        if state then
            -- Ligar o spammer
            spammerVariables.isSpammerActive = true
            setupPromptEvents()
            startSpammer(1)
           
        else
            -- Desligar o spammer
            stopSpammer()
            
        end
    end
})

local servidor = GUI:CreateTab("Servidor", "cloud")

GUI:CreateSection({
    parent = servidor, 
    text = "Server Functions"
})

local TeleportService = game:GetService("TeleportService")

-- Variável para armazenar o Job ID
local currentJobId = ""

-- Input para colar o Job ID
GUI:CreateInput({
    parent = servidor, 
    text = "Job Id", 
    placeholder = "Cole o Job ID aqui e pressione ENTER", 
    flag = "TeleportInput",
    callback = function(text)
        print("Input text:", text)
        currentJobId = text -- Salva o Job ID para usar no botão
        
        -- Sistema de teleporte via ENTER
        local jobId = string.gsub(text, "%s+", "") -- Remove espaços
        
        if jobId == "" then
            GUI:CreateNotify({title = "Erro", description = "Digite um Job ID"})
            return
        end
        
        -- Valida se é um UUID ou número
        local isValid = false
        
        -- Verifica se é UUID (formato com hífens)
        if string.match(jobId, "^[a-fA-F0-9%-]+$") and #jobId >= 32 then
            isValid = true
        -- Verifica se é número (Job ID antigo)
        elseif tonumber(jobId) then
            isValid = true
        end
        
        if isValid then
            GUI:CreateNotify({title = "Teleportando", description = "Job ID: " .. jobId})
            
            -- Tenta o teleporte
            local success, result = pcall(function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, game.Players.LocalPlayer)
            end)
            
            if not success then
                GUI:CreateNotify({title = "Erro", description = "Falha no teleporte: " .. tostring(result)})
            end
        else
            GUI:CreateNotify({title = "Erro", description = "Job ID inválido"})
        end
    end
})

-- Botão de Teleporte
GUI:CreateButton({
    parent = servidor, 
    text = "Teleportar via Job ID", 
    flag = "TeleportBtn",
    callback = function()
        if currentJobId == "" then
            GUI:CreateNotify({title = "Erro", description = "Cole um Job ID no campo acima primeiro!"})
            return
        end
        
        local jobId = string.gsub(currentJobId, "%s+", "") -- Remove espaços
        
        -- Validação
        local isValid = false
        if string.match(jobId, "^[a-fA-F0-9%-]+$") and #jobId >= 32 then
            isValid = true
        elseif tonumber(jobId) then
            isValid = true
        end
        
        if isValid then
            GUI:CreateNotify({title = "Teleportando", description = "Usando Job ID: " .. jobId})
            
            -- Teleporte via botão
            local success, result = pcall(function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, game.Players.LocalPlayer)
            end)
            
            if not success then
                GUI:CreateNotify({title = "Erro", description = "Falha no teleporte: " .. tostring(result)})
            end
        else
            GUI:CreateNotify({title = "Erro", description = "Job ID inválido no campo"})
        end
    end
})

GUI:CreateSection({
    parent = servidor, 
    text = "Servidor"
})

GUI:CreateToggle({
    parent = servidor, 
    text = "Auto Kick", 
    callback = function()
       
    end
})





GUI:CreateToggle({
    parent = servidor, 
    text = "Anti AFK", 
    callback = function()
       
    end
})

antiBeeToggle = GUI:CreateToggle({
    parent = servidor, 
    text = "Anti Bee",
    default = true, 
    callback = function()
        -- Script para remover efeito amarelo e zoom do BeeLauncher
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local Lighting = game:GetService("Lighting")
        local player = Players.LocalPlayer
        local camera = workspace.CurrentCamera

        -- Variáveis
        local effectsRemoved = false
        local originalFOV = camera.FieldOfView
        local connections = {}

        -- Função para remover todos os efeitos visuais
        local function removeAllEffects()
            if effectsRemoved then return end
            effectsRemoved = true

            -- Salvar FOV original
            originalFOV = camera.FieldOfView

            -- 1. Remover efeitos de COR (amarelo)
            for _, effect in pairs(Lighting:GetChildren()) do
                if effect:IsA("ColorCorrectionEffect") or 
                   effect:IsA("BloomEffect") or 
                   effect:IsA("BlurEffect") then
                    effect.Enabled = false
                end
            end

            -- 2. Conexão para manter FOV e desativar efeitos continuamente
            local mainConnection
            mainConnection = RunService.Heartbeat:Connect(function()
                if not effectsRemoved then 
                    mainConnection:Disconnect()
                    return 
                end
                
                -- Manter FOV normal (contra zoom)
                camera.FieldOfView = originalFOV

                -- Remover desfoque e amarelo continuamente
                for _, effect in pairs(Lighting:GetChildren()) do
                    if effect:IsA("BlurEffect") or effect:IsA("ColorCorrectionEffect") then
                        effect.Enabled = false
                        if effect:IsA("BlurEffect") then
                            effect.Size = 0
                        end
                    end
                end
            end)

            table.insert(connections, mainConnection)

            -- 3. Monitorar novos efeitos adicionados
            local lightingConnection = Lighting.ChildAdded:Connect(function(child)
                if effectsRemoved then
                    if child:IsA("BlurEffect") or 
                       child:IsA("ColorCorrectionEffect") or 
                       child:IsA("BloomEffect") then
                        child.Enabled = false
                        if child:IsA("BlurEffect") then
                            child.Size = 0
                        end
                    end
                end
            end)

            table.insert(connections, lightingConnection)

            -- 4. Remover ScreenGuis de efeito
            for _, gui in pairs(player.PlayerGui:GetChildren()) do
                if gui:IsA("ScreenGui") then
                    local name = string.lower(gui.Name)
                    if name:find("effect") or name:find("overlay") or name:find("filter") or name:find("blur") then
                        gui.Enabled = false
                    end
                end
            end

            -- 5. Monitorar novos ScreenGuis
            local guiConnection = player.PlayerGui.ChildAdded:Connect(function(child)
                if effectsRemoved and child:IsA("ScreenGui") then
                    local name = string.lower(child.Name)
                    if name:find("effect") or name:find("overlay") or name:find("filter") or name:find("blur") then
                        child.Enabled = false
                    end
                end
            end)

            table.insert(connections, guiConnection)
        end

        -- Executar a função diretamente ao ativar o toggle
        removeAllEffects()
    end
})

-- Anti Lag Atualizado
antiLagToggle = GUI:CreateToggle({
    parent = servidor, 
    text = "Anti Lag", 
    default = true,
    callback = function(value)
        -- Variável de estado
        local isEnabled = value

        -- Função para remover skins de um personagem
        local function removeSkinsFromCharacter(character)
            pcall(function()
                -- Remover roupas e acessórios
                for _, item in ipairs(character:GetChildren()) do
                    if item:IsA("Accessory") or item:IsA("Shirt") or item:IsA("Pants") or item:IsA("ShirtGraphic") then
                        item:Destroy()
                    end
                end
                
                -- Remover texturas do corpo
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    -- Remover bodies
                    for _, bodyPart in ipairs(character:GetChildren()) do
                        if bodyPart:IsA("BasePart") then
                            -- Remover texturas e materiais
                            bodyPart.Material = Enum.Material.SmoothPlastic
                            bodyPart.BrickColor = BrickColor.new("Medium stone grey")
                            
                            -- Remover decal (skin)
                            for _, decal in ipairs(bodyPart:GetChildren()) do
                                if decal:IsA("Decal") then
                                    decal:Destroy()
                                end
                            end
                        end
                    end
                    
                    -- Remover head mesh (cabelo, etc)
                    local head = character:FindFirstChild("Head")
                    if head then
                        for _, item in ipairs(head:GetChildren()) do
                            if item:IsA("SpecialMesh") or item:IsA("MeshPart") then
                                item:Destroy()
                            end
                        end
                    end
                end
            end)
        end

        -- Loop principal de remoção de skins
        local function startSkinRemoval()
            if _G.skinRemovalLoop then 
                _G.skinRemovalLoop:Disconnect()
            end
            
            
            -- Remover skin do próprio player primeiro
            if game.Players.LocalPlayer.Character then
                removeSkinsFromCharacter(game.Players.LocalPlayer.Character)
            end
            
            -- Remover skins de todos os outros players
            for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                if otherPlayer.Character then
                    removeSkinsFromCharacter(otherPlayer.Character)
                end
            end
            
            -- Monitorar continuamente
            _G.skinRemovalLoop = game:GetService("RunService").Heartbeat:Connect(function()
                -- Verificar todos os players no workspace
                for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                    if otherPlayer.Character and otherPlayer.Character:FindFirstChild("Humanoid") then
                        removeSkinsFromCharacter(otherPlayer.Character)
                    end
                end
                
                -- Verificar modelos que podem ser clones
                for _, model in ipairs(workspace:GetChildren()) do
                    if model:IsA("Model") and model:FindFirstChild("Humanoid") then
                        -- Verificar se é um clone (tem humanoid mas não é de um player)
                        local isPlayerCharacter = false
                        for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                            if otherPlayer.Character == model then
                                isPlayerCharacter = true
                                break
                            end
                        end
                        
                        if not isPlayerCharacter then
                            removeSkinsFromCharacter(model)
                        end
                    end
                end
            end)
        end

        -- Função para parar a remoção de skins
        local function stopSkinRemoval()
            if _G.skinRemovalLoop then
                _G.skinRemovalLoop:Disconnect()
                _G.skinRemovalLoop = nil
            end
            
            if _G.playerAddedConnection then
                _G.playerAddedConnection:Disconnect()
                _G.playerAddedConnection = nil
            end
            
            if _G.characterAddedConnection then
                _G.characterAddedConnection:Disconnect()
                _G.characterAddedConnection = nil
            end
        end

        -- Ativar Anti Lag
        if value then
            -- Monitorar quando novos players entram
            _G.playerAddedConnection = game.Players.PlayerAdded:Connect(function(otherPlayer)
                _G.characterAddedConnection = otherPlayer.CharacterAdded:Connect(function(character)
                    task.wait(1)
                    removeSkinsFromCharacter(character)
                end)
            end)

            -- Aplicar remoção de skins em players existentes
            for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                if otherPlayer.Character then
                    removeSkinsFromCharacter(otherPlayer.Character)
                end
            end

            -- Reconectar quando o personagem do player morrer
            _G.localPlayerConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
                task.wait(2)
                removeSkinsFromCharacter(character)
            end)

            -- Iniciar automaticamente
            startSkinRemoval()



        -- Desativar Anti Lag
        else
            stopSkinRemoval()
        end
    end
})


local information = GUI:CreateTab("VIPs", "crown")

GUI:CreateSection({
    parent = information, 
    text = "VIPs Functions"
})

GUI:CreateToggle({
    parent = information, 
    text = "Server Privado", 
    callback = function(value)
        if value then
            -- [Código Server Privado permanece igual...]
        end
    end
})

GUI:CreateToggle({
    parent = information, 
    text = "Notfy Vip", 
    callback = function()
       
    end
})

-- NOVA ABA DE KEYBINDS COM SISTEMA DE SALVAMENTO
local keybindsTab = GUI:CreateTab("Keybinds", "keyboard")

GUI:CreateSection({
    parent = keybindsTab, 
    text = "Keybinds - Toggle de Funções"
})

-- Função para criar UI de keybind
local keybindElements = {}

local function createKeybindUI(parent, name, defaultKey, callback)
    local keybindData = KeybindSystem:RegisterKeybind(name, defaultKey, callback)
    
    local container = Instance.new("Frame")
    container.BackgroundTransparency = 1
    container.Size = UDim2.new(1, 0, 0, 40)
    container.Parent = parent
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.6, 0, 1, 0)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = name
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Font = Enum.Font.Gotham
    label.Parent = container
    
    local keybindButton = Instance.new("TextButton")
    keybindButton.Size = UDim2.new(0.3, 0, 0.7, 0)
    keybindButton.Position = UDim2.new(0.65, 0, 0.15, 0)
    keybindButton.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
    keybindButton.BorderSizePixel = 0
    keybindButton.Text = keybindData.key -- Usa a key carregada/salva
    keybindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    keybindButton.TextSize = 12
    keybindButton.Font = Enum.Font.Gotham
    keybindButton.Parent = container
    
    local listening = false
    
    keybindButton.MouseButton1Click:Connect(function()
        if not listening then
            listening = true
            keybindButton.Text = "..."
            keybindButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
            
            local connection
            connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    local newKey = input.KeyCode.Name
                    
                    -- Atualiza o keybind no sistema
                    KeybindSystem:UpdateKeybind(name, newKey)
                    
                    -- Atualiza o botão visualmente
                    keybindButton.Text = newKey
                    keybindButton.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
                    listening = false
                    connection:Disconnect()
                    
                    print("Keybind " .. name .. " atualizado para: " .. newKey)
                    print("Keybind salvo automaticamente!")
                end
            end)
        end
    end)
    
    keybindElements[name] = {
        container = container,
        button = keybindButton,
        data = keybindData
    }
    
    return container
end

-- KEYBINDS APENAS PARA FUNÇÕES QUE JÁ EXISTEM NOS TOGGLES

-- Visual
createKeybindUI(keybindsTab, "ESP Inimigos", "F1", function()
    if espToggle then
        espToggle:Set(not espToggle:Get())
        print("ESP Inimigos toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "ESP Brainrot", "F2", function()
    if brainrotEspToggle then
        brainrotEspToggle:Set(not brainrotEspToggle:Get())
        print("ESP Brainrot toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "ESP Timer Base", "F3", function()
    if timerEspToggle then
        timerEspToggle:Set(not timerEspToggle:Get())
        print("ESP Timer Base toggleado via keybind!")
    end
end)

-- Outros
createKeybindUI(keybindsTab, "Desync", "F4", function()
    if desyncToggle then
        desyncToggle:Set(not desyncToggle:Get())
        print("Desync toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "InfinfiniteJump", "F4", function()
    if infiniteJumpToggle then
        infiniteJumpToggle:Set(not infiniteJumpToggle:Get())
        print("infiniteJump toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Float Base", "F5", function()
    if floatToggle then
        floatToggle:Set(not floatToggle:Get())
        print("Float Base toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Auto Pull", "F5", function()
    if floatToggle then
        floatToggle:Set(not AutoPullToggle:Get())
        print("Auto Pull toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Steal floor", "F5", function()
    if floatToggle then
        floatToggle:Set(not StealfloorToggle:Get())
        print("Steal floor toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Travar Players", "F6", function()
    if travarToggle then
        travarToggle:Set(not travarToggle:Get())
        print("Travar Players toggleado via keybind!")
    end
end)

-- Servidor
createKeybindUI(keybindsTab, "Anti Bee", "F7", function()
    if antiBeeToggle then
        antiBeeToggle:Set(not antiBeeToggle:Get())
        print("Anti Bee toggleado via keybind!")
    end
end)

createKeybindUI(keybindsTab, "Anti Lag", "F8", function()
    if antiLagToggle then
        antiLagToggle:Set(not antiLagToggle:Get())
        print("Anti Lag toggleado via keybind!")
    end
end)

-- Main
createKeybindUI(keybindsTab, "Aimbot Beta", "F9", function()
    if aimbotToggle then
        aimbotToggle:Set(not aimbotToggle:Get())
        print("Aimbot Beta toggleado via keybind!")
    end
end)

-- Botão para resetar todos os keybinds
GUI:CreateSection({
    parent = keybindsTab, 
    text = "Gerenciamento"
})

local resetButton = Instance.new("TextButton")
resetButton.Size = UDim2.new(0.8, 0, 0, 30)
resetButton.Position = UDim2.new(0.1, 0, 0, 0)
resetButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
resetButton.BorderSizePixel = 0
resetButton.Text = "Resetar Todos Keybinds"
resetButton.TextColor3 = Color3.fromRGB(255, 255, 255)
resetButton.TextSize = 12
resetButton.Font = Enum.Font.Gotham
resetButton.Parent = keybindsTab

resetButton.MouseButton1Click:Connect(function()
    -- Deleta o arquivo de salvamento
    local success = pcall(function()
        delfile(KeybindSystem.SaveFile)
    end)
    
    -- Recarrega a interface
    for name, element in pairs(keybindElements) do
        if element.button then
            local defaultKey = ""
            if name == "ESP Inimigos" then defaultKey = "F1"
            elseif name == "ESP Brainrot" then defaultKey = "F2"
            elseif name == "ESP Timer Base" then defaultKey = "F3"
            elseif name == "Desync" then defaultKey = "F4"
            elseif name == "Float Base" then defaultKey = "F5"
            elseif name == "Travar Players" then defaultKey = "F6"
            elseif name == "Anti Bee" then defaultKey = "F7"
            elseif name == "Anti Lag" then defaultKey = "F8"
            elseif name == "Aimbot Beta" then defaultKey = "F9"
            end
            
            KeybindSystem:UpdateKeybind(name, defaultKey)
            element.button.Text = defaultKey
        end
    end
    
    print("Todos os keybinds foram resetados para padrão!")
end)

-- Seção de informações
GUI:CreateSection({
    parent = keybindsTab, 
    text = "Instruções"
})

-- Texto informativo
local infoLabel = Instance.new("TextLabel")
infoLabel.Size = UDim2.new(1, 0, 0, 100)
infoLabel.Position = UDim2.new(0, 0, 0, 0)
infoLabel.BackgroundTransparency = 1
infoLabel.Text = "Sistema de Keybinds com Salvamento:\n• Clique no botão do keybind\n• Pressione a tecla desejada\n• As keybinds são salvas automaticamente\n• Funcionam após reinjetar o script\n• Use o botão vermelho para resetar\n\nArquivo: Ashlabs_Keybinds.txt"
infoLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
infoLabel.TextSize = 12
infoLabel.TextWrapped = true
infoLabel.TextXAlignment = Enum.TextXAlignment.Left
infoLabel.Font = Enum.Font.Gotham
infoLabel.Parent = keybindsTab

-- Notificação de keybinds carregados
print("=== SISTEMA DE KEYBINDS CARREGADO ===")
print("Arquivo de salvamento: " .. KeybindSystem.SaveFile)

-- Verifica se carregou keybinds salvos
local savedKeybinds = KeybindSystem:LoadKeybinds()
if savedKeybinds then
    print("Keybinds anteriores carregados com sucesso!")
    for name, key in pairs(savedKeybinds) do
        print("- " .. name .. ": " .. key)
    end
else
    print("Usando keybinds padrão (F1-F9)")
end

print("=====================================")

-- Carrega o Notfly automaticamente
local function loadNotfly()
    local success, err = pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/teuzzjheyt/Notfly/refs/heads/main/Notfly",true))()
    end)
    if not success then
        warn("Erro ao carregar o script Notfly:", err)
    else
        print("Script Notfly carregado com sucesso!")
    end
end

loadNotfly()
